var t = {}
  , e = {};
function a(t) {
    let e = t.length;
    for (; --e >= 0; )
        t[e] = 0
}
const s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  , r = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  , n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  , i = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , _ = new Array(576);
a(_);
const l = new Array(60);
a(l);
const h = new Array(512);
a(h);
const o = new Array(256);
a(o);
const d = new Array(29);
a(d);
const u = new Array(30);
function f(t, e, a, s, r) {
    this.static_tree = t,
    this.extra_bits = e,
    this.extra_base = a,
    this.elems = s,
    this.max_length = r,
    this.has_stree = t && t.length
}
let c, p, g;
function w(t, e) {
    this.dyn_tree = t,
    this.max_code = 0,
    this.stat_desc = e
}
a(u);
const m = t => t < 256 ? h[t] : h[256 + (t >>> 7)]
  , b = (t, e) => {
    t.pending_buf[t.pending++] = 255 & e,
    t.pending_buf[t.pending++] = e >>> 8 & 255
}
  , y = (t, e, a) => {
    t.bi_valid > 16 - a ? (t.bi_buf |= e << t.bi_valid & 65535,
    b(t, t.bi_buf),
    t.bi_buf = e >> 16 - t.bi_valid,
    t.bi_valid += a - 16) : (t.bi_buf |= e << t.bi_valid & 65535,
    t.bi_valid += a)
}
  , v = (t, e, a) => {
    y(t, a[2 * e], a[2 * e + 1])
}
  , z = (t, e) => {
    let a = 0;
    do {
        a |= 1 & t,
        t >>>= 1,
        a <<= 1
    } while (--e > 0);
    return a >>> 1
}
  , k = (t, e, a) => {
    const s = new Array(16);
    let r, n, i = 0;
    for (r = 1; r <= 15; r++)
        i = i + a[r - 1] << 1,
        s[r] = i;
    for (n = 0; n <= e; n++) {
        let e = t[2 * n + 1];
        0 !== e && (t[2 * n] = z(s[e]++, e))
    }
}
  , x = t => {
    let e;
    for (e = 0; e < 286; e++)
        t.dyn_ltree[2 * e] = 0;
    for (e = 0; e < 30; e++)
        t.dyn_dtree[2 * e] = 0;
    for (e = 0; e < 19; e++)
        t.bl_tree[2 * e] = 0;
    t.dyn_ltree[512] = 1,
    t.opt_len = t.static_len = 0,
    t.sym_next = t.matches = 0
}
  , A = t => {
    t.bi_valid > 8 ? b(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
    t.bi_buf = 0,
    t.bi_valid = 0
}
  , E = (t, e, a, s) => {
    const r = 2 * e
      , n = 2 * a;
    return t[r] < t[n] || t[r] === t[n] && s[e] <= s[a]
}
  , Z = (t, e, a) => {
    const s = t.heap[a];
    let r = a << 1;
    for (; r <= t.heap_len && (r < t.heap_len && E(e, t.heap[r + 1], t.heap[r], t.depth) && r++,
    !E(e, s, t.heap[r], t.depth)); )
        t.heap[a] = t.heap[r],
        a = r,
        r <<= 1;
    t.heap[a] = s
}
  , S = (t, e, a) => {
    let n, i, _, l, h = 0;
    if (0 !== t.sym_next)
        do {
            n = 255 & t.pending_buf[t.sym_buf + h++],
            n += (255 & t.pending_buf[t.sym_buf + h++]) << 8,
            i = t.pending_buf[t.sym_buf + h++],
            0 === n ? v(t, i, e) : (_ = o[i],
            v(t, _ + 256 + 1, e),
            l = s[_],
            0 !== l && (i -= d[_],
            y(t, i, l)),
            n--,
            _ = m(n),
            v(t, _, a),
            l = r[_],
            0 !== l && (n -= u[_],
            y(t, n, l)))
        } while (h < t.sym_next);
    v(t, 256, e)
}
  , U = (t, e) => {
    const a = e.dyn_tree
      , s = e.stat_desc.static_tree
      , r = e.stat_desc.has_stree
      , n = e.stat_desc.elems;
    let i, _, l, h = -1;
    for (t.heap_len = 0,
    t.heap_max = 573,
    i = 0; i < n; i++)
        0 !== a[2 * i] ? (t.heap[++t.heap_len] = h = i,
        t.depth[i] = 0) : a[2 * i + 1] = 0;
    for (; t.heap_len < 2; )
        l = t.heap[++t.heap_len] = h < 2 ? ++h : 0,
        a[2 * l] = 1,
        t.depth[l] = 0,
        t.opt_len--,
        r && (t.static_len -= s[2 * l + 1]);
    for (e.max_code = h,
    i = t.heap_len >> 1; i >= 1; i--)
        Z(t, a, i);
    l = n;
    do {
        i = t.heap[1],
        t.heap[1] = t.heap[t.heap_len--],
        Z(t, a, 1),
        _ = t.heap[1],
        t.heap[--t.heap_max] = i,
        t.heap[--t.heap_max] = _,
        a[2 * l] = a[2 * i] + a[2 * _],
        t.depth[l] = (t.depth[i] >= t.depth[_] ? t.depth[i] : t.depth[_]) + 1,
        a[2 * i + 1] = a[2 * _ + 1] = l,
        t.heap[1] = l++,
        Z(t, a, 1)
    } while (t.heap_len >= 2);
    t.heap[--t.heap_max] = t.heap[1],
    ( (t, e) => {
        const a = e.dyn_tree
          , s = e.max_code
          , r = e.stat_desc.static_tree
          , n = e.stat_desc.has_stree
          , i = e.stat_desc.extra_bits
          , _ = e.stat_desc.extra_base
          , l = e.stat_desc.max_length;
        let h, o, d, u, f, c, p = 0;
        for (u = 0; u <= 15; u++)
            t.bl_count[u] = 0;
        for (a[2 * t.heap[t.heap_max] + 1] = 0,
        h = t.heap_max + 1; h < 573; h++)
            o = t.heap[h],
            u = a[2 * a[2 * o + 1] + 1] + 1,
            u > l && (u = l,
            p++),
            a[2 * o + 1] = u,
            o > s || (t.bl_count[u]++,
            f = 0,
            o >= _ && (f = i[o - _]),
            c = a[2 * o],
            t.opt_len += c * (u + f),
            n && (t.static_len += c * (r[2 * o + 1] + f)));
        if (0 !== p) {
            do {
                for (u = l - 1; 0 === t.bl_count[u]; )
                    u--;
                t.bl_count[u]--,
                t.bl_count[u + 1] += 2,
                t.bl_count[l]--,
                p -= 2
            } while (p > 0);
            for (u = l; 0 !== u; u--)
                for (o = t.bl_count[u]; 0 !== o; )
                    d = t.heap[--h],
                    d > s || (a[2 * d + 1] !== u && (t.opt_len += (u - a[2 * d + 1]) * a[2 * d],
                    a[2 * d + 1] = u),
                    o--)
        }
    }
    )(t, e),
    k(a, h, t.bl_count)
}
  , R = (t, e, a) => {
    let s, r, n = -1, i = e[1], _ = 0, l = 7, h = 4;
    for (0 === i && (l = 138,
    h = 3),
    e[2 * (a + 1) + 1] = 65535,
    s = 0; s <= a; s++)
        r = i,
        i = e[2 * (s + 1) + 1],
        ++_ < l && r === i || (_ < h ? t.bl_tree[2 * r] += _ : 0 !== r ? (r !== n && t.bl_tree[2 * r]++,
        t.bl_tree[32]++) : _ <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++,
        _ = 0,
        n = r,
        0 === i ? (l = 138,
        h = 3) : r === i ? (l = 6,
        h = 3) : (l = 7,
        h = 4))
}
  , L = (t, e, a) => {
    let s, r, n = -1, i = e[1], _ = 0, l = 7, h = 4;
    for (0 === i && (l = 138,
    h = 3),
    s = 0; s <= a; s++)
        if (r = i,
        i = e[2 * (s + 1) + 1],
        !(++_ < l && r === i)) {
            if (_ < h)
                do {
                    v(t, r, t.bl_tree)
                } while (0 != --_);
            else
                0 !== r ? (r !== n && (v(t, r, t.bl_tree),
                _--),
                v(t, 16, t.bl_tree),
                y(t, _ - 3, 2)) : _ <= 10 ? (v(t, 17, t.bl_tree),
                y(t, _ - 3, 3)) : (v(t, 18, t.bl_tree),
                y(t, _ - 11, 7));
            _ = 0,
            n = r,
            0 === i ? (l = 138,
            h = 3) : r === i ? (l = 6,
            h = 3) : (l = 7,
            h = 4)
        }
}
;
let T = !1;
const F = (t, e, a, s) => {
    y(t, 0 + (s ? 1 : 0), 3),
    A(t),
    b(t, a),
    b(t, ~a),
    a && t.pending_buf.set(t.window.subarray(e, e + a), t.pending),
    t.pending += a
}
;
e._tr_init = t => {
    T || (( () => {
        let t, e, a, i, w;
        const m = new Array(16);
        for (a = 0,
        i = 0; i < 28; i++)
            for (d[i] = a,
            t = 0; t < 1 << s[i]; t++)
                o[a++] = i;
        for (o[a - 1] = i,
        w = 0,
        i = 0; i < 16; i++)
            for (u[i] = w,
            t = 0; t < 1 << r[i]; t++)
                h[w++] = i;
        for (w >>= 7; i < 30; i++)
            for (u[i] = w << 7,
            t = 0; t < 1 << r[i] - 7; t++)
                h[256 + w++] = i;
        for (e = 0; e <= 15; e++)
            m[e] = 0;
        for (t = 0; t <= 143; )
            _[2 * t + 1] = 8,
            t++,
            m[8]++;
        for (; t <= 255; )
            _[2 * t + 1] = 9,
            t++,
            m[9]++;
        for (; t <= 279; )
            _[2 * t + 1] = 7,
            t++,
            m[7]++;
        for (; t <= 287; )
            _[2 * t + 1] = 8,
            t++,
            m[8]++;
        for (k(_, 287, m),
        t = 0; t < 30; t++)
            l[2 * t + 1] = 5,
            l[2 * t] = z(t, 5);
        c = new f(_,s,257,286,15),
        p = new f(l,r,0,30,15),
        g = new f(new Array(0),n,0,19,7)
    }
    )(),
    T = !0),
    t.l_desc = new w(t.dyn_ltree,c),
    t.d_desc = new w(t.dyn_dtree,p),
    t.bl_desc = new w(t.bl_tree,g),
    t.bi_buf = 0,
    t.bi_valid = 0,
    x(t)
}
,
e._tr_stored_block = F,
e._tr_flush_block = (t, e, a, s) => {
    let r, n, h = 0;
    t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = (t => {
        let e, a = 4093624447;
        for (e = 0; e <= 31; e++,
        a >>>= 1)
            if (1 & a && 0 !== t.dyn_ltree[2 * e])
                return 0;
        if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26])
            return 1;
        for (e = 32; e < 256; e++)
            if (0 !== t.dyn_ltree[2 * e])
                return 1;
        return 0
    }
    )(t)),
    U(t, t.l_desc),
    U(t, t.d_desc),
    h = (t => {
        let e;
        for (R(t, t.dyn_ltree, t.l_desc.max_code),
        R(t, t.dyn_dtree, t.d_desc.max_code),
        U(t, t.bl_desc),
        e = 18; e >= 3 && 0 === t.bl_tree[2 * i[e] + 1]; e--)
            ;
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4,
        e
    }
    )(t),
    r = t.opt_len + 3 + 7 >>> 3,
    n = t.static_len + 3 + 7 >>> 3,
    n <= r && (r = n)) : r = n = a + 5,
    a + 4 <= r && -1 !== e ? F(t, e, a, s) : 4 === t.strategy || n === r ? (y(t, 2 + (s ? 1 : 0), 3),
    S(t, _, l)) : (y(t, 4 + (s ? 1 : 0), 3),
    ( (t, e, a, s) => {
        let r;
        for (y(t, e - 257, 5),
        y(t, a - 1, 5),
        y(t, s - 4, 4),
        r = 0; r < s; r++)
            y(t, t.bl_tree[2 * i[r] + 1], 3);
        L(t, t.dyn_ltree, e - 1),
        L(t, t.dyn_dtree, a - 1)
    }
    )(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, h + 1),
    S(t, t.dyn_ltree, t.dyn_dtree)),
    x(t),
    s && A(t)
}
,
e._tr_tally = (t, e, a) => (t.pending_buf[t.sym_buf + t.sym_next++] = e,
t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8,
t.pending_buf[t.sym_buf + t.sym_next++] = a,
0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++,
e--,
t.dyn_ltree[2 * (o[a] + 256 + 1)]++,
t.dyn_dtree[2 * m(e)]++),
t.sym_next === t.sym_end),
e._tr_align = t => {
    y(t, 2, 3),
    v(t, 256, _),
    (t => {
        16 === t.bi_valid ? (b(t, t.bi_buf),
        t.bi_buf = 0,
        t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf,
        t.bi_buf >>= 8,
        t.bi_valid -= 8)
    }
    )(t)
}
;
var O = (t, e, a, s) => {
    let r = 65535 & t | 0
      , n = t >>> 16 & 65535 | 0
      , i = 0;
    for (; 0 !== a; ) {
        i = a > 2e3 ? 2e3 : a,
        a -= i;
        do {
            r = r + e[s++] | 0,
            n = n + r | 0
        } while (--i);
        r %= 65521,
        n %= 65521
    }
    return r | n << 16 | 0
}
;
const D = new Uint32Array(( () => {
    let t, e = [];
    for (var a = 0; a < 256; a++) {
        t = a;
        for (var s = 0; s < 8; s++)
            t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
        e[a] = t
    }
    return e
}
)());
var N = (t, e, a, s) => {
    const r = D
      , n = s + a;
    t ^= -1;
    for (let a = s; a < n; a++)
        t = t >>> 8 ^ r[255 & (t ^ e[a])];
    return -1 ^ t
}
  , C = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}
  , I = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
const {_tr_init: H, _tr_stored_block: B, _tr_flush_block: M, _tr_tally: P, _tr_align: Y} = e
  , K = O
  , j = N
  , G = C
  , {Z_NO_FLUSH: X, Z_PARTIAL_FLUSH: W, Z_FULL_FLUSH: q, Z_FINISH: J, Z_BLOCK: Q, Z_OK: V, Z_STREAM_END: $, Z_STREAM_ERROR: tt, Z_DATA_ERROR: et, Z_BUF_ERROR: at, Z_DEFAULT_COMPRESSION: st, Z_FILTERED: rt, Z_HUFFMAN_ONLY: nt, Z_RLE: it, Z_FIXED: _t, Z_DEFAULT_STRATEGY: lt, Z_UNKNOWN: ht, Z_DEFLATED: ot} = I
  , dt = (t, e) => (t.msg = G[e],
e)
  , ut = t => 2 * t - (t > 4 ? 9 : 0)
  , ft = t => {
    let e = t.length;
    for (; --e >= 0; )
        t[e] = 0
}
  , ct = t => {
    let e, a, s, r = t.w_size;
    e = t.hash_size,
    s = e;
    do {
        a = t.head[--s],
        t.head[s] = a >= r ? a - r : 0
    } while (--e);
    e = r,
    s = e;
    do {
        a = t.prev[--s],
        t.prev[s] = a >= r ? a - r : 0
    } while (--e)
}
;
let pt = (t, e, a) => (e << t.hash_shift ^ a) & t.hash_mask;
const gt = t => {
    const e = t.state;
    let a = e.pending;
    a > t.avail_out && (a = t.avail_out),
    0 !== a && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + a), t.next_out),
    t.next_out += a,
    e.pending_out += a,
    t.total_out += a,
    t.avail_out -= a,
    e.pending -= a,
    0 === e.pending && (e.pending_out = 0))
}
  , wt = (t, e) => {
    M(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e),
    t.block_start = t.strstart,
    gt(t.strm)
}
  , mt = (t, e) => {
    t.pending_buf[t.pending++] = e
}
  , bt = (t, e) => {
    t.pending_buf[t.pending++] = e >>> 8 & 255,
    t.pending_buf[t.pending++] = 255 & e
}
  , yt = (t, e, a, s) => {
    let r = t.avail_in;
    return r > s && (r = s),
    0 === r ? 0 : (t.avail_in -= r,
    e.set(t.input.subarray(t.next_in, t.next_in + r), a),
    1 === t.state.wrap ? t.adler = K(t.adler, e, r, a) : 2 === t.state.wrap && (t.adler = j(t.adler, e, r, a)),
    t.next_in += r,
    t.total_in += r,
    r)
}
  , vt = (t, e) => {
    let a, s, r = t.max_chain_length, n = t.strstart, i = t.prev_length, _ = t.nice_match;
    const l = t.strstart > t.w_size - 262 ? t.strstart - (t.w_size - 262) : 0
      , h = t.window
      , o = t.w_mask
      , d = t.prev
      , u = t.strstart + 258;
    let f = h[n + i - 1]
      , c = h[n + i];
    t.prev_length >= t.good_match && (r >>= 2),
    _ > t.lookahead && (_ = t.lookahead);
    do {
        if (a = e,
        h[a + i] === c && h[a + i - 1] === f && h[a] === h[n] && h[++a] === h[n + 1]) {
            n += 2,
            a++;
            do {} while (h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && h[++n] === h[++a] && n < u);
            if (s = 258 - (u - n),
            n = u - 258,
            s > i) {
                if (t.match_start = e,
                i = s,
                s >= _)
                    break;
                f = h[n + i - 1],
                c = h[n + i]
            }
        }
    } while ((e = d[e & o]) > l && 0 != --r);
    return i <= t.lookahead ? i : t.lookahead
}
  , zt = t => {
    const e = t.w_size;
    let a, s, r;
    do {
        if (s = t.window_size - t.lookahead - t.strstart,
        t.strstart >= e + (e - 262) && (t.window.set(t.window.subarray(e, e + e - s), 0),
        t.match_start -= e,
        t.strstart -= e,
        t.block_start -= e,
        t.insert > t.strstart && (t.insert = t.strstart),
        ct(t),
        s += e),
        0 === t.strm.avail_in)
            break;
        if (a = yt(t.strm, t.window, t.strstart + t.lookahead, s),
        t.lookahead += a,
        t.lookahead + t.insert >= 3)
            for (r = t.strstart - t.insert,
            t.ins_h = t.window[r],
            t.ins_h = pt(t, t.ins_h, t.window[r + 1]); t.insert && (t.ins_h = pt(t, t.ins_h, t.window[r + 3 - 1]),
            t.prev[r & t.w_mask] = t.head[t.ins_h],
            t.head[t.ins_h] = r,
            r++,
            t.insert--,
            !(t.lookahead + t.insert < 3)); )
                ;
    } while (t.lookahead < 262 && 0 !== t.strm.avail_in)
}
  , kt = (t, e) => {
    let a, s, r, n = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5, i = 0, _ = t.strm.avail_in;
    do {
        if (a = 65535,
        r = t.bi_valid + 42 >> 3,
        t.strm.avail_out < r)
            break;
        if (r = t.strm.avail_out - r,
        s = t.strstart - t.block_start,
        a > s + t.strm.avail_in && (a = s + t.strm.avail_in),
        a > r && (a = r),
        a < n && (0 === a && e !== J || e === X || a !== s + t.strm.avail_in))
            break;
        i = e === J && a === s + t.strm.avail_in ? 1 : 0,
        B(t, 0, 0, i),
        t.pending_buf[t.pending - 4] = a,
        t.pending_buf[t.pending - 3] = a >> 8,
        t.pending_buf[t.pending - 2] = ~a,
        t.pending_buf[t.pending - 1] = ~a >> 8,
        gt(t.strm),
        s && (s > a && (s = a),
        t.strm.output.set(t.window.subarray(t.block_start, t.block_start + s), t.strm.next_out),
        t.strm.next_out += s,
        t.strm.avail_out -= s,
        t.strm.total_out += s,
        t.block_start += s,
        a -= s),
        a && (yt(t.strm, t.strm.output, t.strm.next_out, a),
        t.strm.next_out += a,
        t.strm.avail_out -= a,
        t.strm.total_out += a)
    } while (0 === i);
    return _ -= t.strm.avail_in,
    _ && (_ >= t.w_size ? (t.matches = 2,
    t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0),
    t.strstart = t.w_size,
    t.insert = t.strstart) : (t.window_size - t.strstart <= _ && (t.strstart -= t.w_size,
    t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
    t.matches < 2 && t.matches++,
    t.insert > t.strstart && (t.insert = t.strstart)),
    t.window.set(t.strm.input.subarray(t.strm.next_in - _, t.strm.next_in), t.strstart),
    t.strstart += _,
    t.insert += _ > t.w_size - t.insert ? t.w_size - t.insert : _),
    t.block_start = t.strstart),
    t.high_water < t.strstart && (t.high_water = t.strstart),
    i ? 4 : e !== X && e !== J && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (r = t.window_size - t.strstart,
    t.strm.avail_in > r && t.block_start >= t.w_size && (t.block_start -= t.w_size,
    t.strstart -= t.w_size,
    t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0),
    t.matches < 2 && t.matches++,
    r += t.w_size,
    t.insert > t.strstart && (t.insert = t.strstart)),
    r > t.strm.avail_in && (r = t.strm.avail_in),
    r && (yt(t.strm, t.window, t.strstart, r),
    t.strstart += r,
    t.insert += r > t.w_size - t.insert ? t.w_size - t.insert : r),
    t.high_water < t.strstart && (t.high_water = t.strstart),
    r = t.bi_valid + 42 >> 3,
    r = t.pending_buf_size - r > 65535 ? 65535 : t.pending_buf_size - r,
    n = r > t.w_size ? t.w_size : r,
    s = t.strstart - t.block_start,
    (s >= n || (s || e === J) && e !== X && 0 === t.strm.avail_in && s <= r) && (a = s > r ? r : s,
    i = e === J && 0 === t.strm.avail_in && a === s ? 1 : 0,
    B(t, t.block_start, a, i),
    t.block_start += a,
    gt(t.strm)),
    i ? 3 : 1)
}
  , xt = (t, e) => {
    let a, s;
    for (; ; ) {
        if (t.lookahead < 262) {
            if (zt(t),
            t.lookahead < 262 && e === X)
                return 1;
            if (0 === t.lookahead)
                break
        }
        if (a = 0,
        t.lookahead >= 3 && (t.ins_h = pt(t, t.ins_h, t.window[t.strstart + 3 - 1]),
        a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
        t.head[t.ins_h] = t.strstart),
        0 !== a && t.strstart - a <= t.w_size - 262 && (t.match_length = vt(t, a)),
        t.match_length >= 3)
            if (s = P(t, t.strstart - t.match_start, t.match_length - 3),
            t.lookahead -= t.match_length,
            t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
                t.match_length--;
                do {
                    t.strstart++,
                    t.ins_h = pt(t, t.ins_h, t.window[t.strstart + 3 - 1]),
                    a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                    t.head[t.ins_h] = t.strstart
                } while (0 != --t.match_length);
                t.strstart++
            } else
                t.strstart += t.match_length,
                t.match_length = 0,
                t.ins_h = t.window[t.strstart],
                t.ins_h = pt(t, t.ins_h, t.window[t.strstart + 1]);
        else
            s = P(t, 0, t.window[t.strstart]),
            t.lookahead--,
            t.strstart++;
        if (s && (wt(t, !1),
        0 === t.strm.avail_out))
            return 1
    }
    return t.insert = t.strstart < 2 ? t.strstart : 2,
    e === J ? (wt(t, !0),
    0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (wt(t, !1),
    0 === t.strm.avail_out) ? 1 : 2
}
  , At = (t, e) => {
    let a, s, r;
    for (; ; ) {
        if (t.lookahead < 262) {
            if (zt(t),
            t.lookahead < 262 && e === X)
                return 1;
            if (0 === t.lookahead)
                break
        }
        if (a = 0,
        t.lookahead >= 3 && (t.ins_h = pt(t, t.ins_h, t.window[t.strstart + 3 - 1]),
        a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
        t.head[t.ins_h] = t.strstart),
        t.prev_length = t.match_length,
        t.prev_match = t.match_start,
        t.match_length = 2,
        0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - 262 && (t.match_length = vt(t, a),
        t.match_length <= 5 && (t.strategy === rt || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)),
        t.prev_length >= 3 && t.match_length <= t.prev_length) {
            r = t.strstart + t.lookahead - 3,
            s = P(t, t.strstart - 1 - t.prev_match, t.prev_length - 3),
            t.lookahead -= t.prev_length - 1,
            t.prev_length -= 2;
            do {
                ++t.strstart <= r && (t.ins_h = pt(t, t.ins_h, t.window[t.strstart + 3 - 1]),
                a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                t.head[t.ins_h] = t.strstart)
            } while (0 != --t.prev_length);
            if (t.match_available = 0,
            t.match_length = 2,
            t.strstart++,
            s && (wt(t, !1),
            0 === t.strm.avail_out))
                return 1
        } else if (t.match_available) {
            if (s = P(t, 0, t.window[t.strstart - 1]),
            s && wt(t, !1),
            t.strstart++,
            t.lookahead--,
            0 === t.strm.avail_out)
                return 1
        } else
            t.match_available = 1,
            t.strstart++,
            t.lookahead--
    }
    return t.match_available && (s = P(t, 0, t.window[t.strstart - 1]),
    t.match_available = 0),
    t.insert = t.strstart < 2 ? t.strstart : 2,
    e === J ? (wt(t, !0),
    0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (wt(t, !1),
    0 === t.strm.avail_out) ? 1 : 2
}
;
function Et(t, e, a, s, r) {
    this.good_length = t,
    this.max_lazy = e,
    this.nice_length = a,
    this.max_chain = s,
    this.func = r
}
const Zt = [new Et(0,0,0,0,kt), new Et(4,4,8,4,xt), new Et(4,5,16,8,xt), new Et(4,6,32,32,xt), new Et(4,4,16,16,At), new Et(8,16,32,32,At), new Et(8,16,128,128,At), new Et(8,32,128,256,At), new Et(32,128,258,1024,At), new Et(32,258,258,4096,At)];
function St() {
    this.strm = null,
    this.status = 0,
    this.pending_buf = null,
    this.pending_buf_size = 0,
    this.pending_out = 0,
    this.pending = 0,
    this.wrap = 0,
    this.gzhead = null,
    this.gzindex = 0,
    this.method = ot,
    this.last_flush = -1,
    this.w_size = 0,
    this.w_bits = 0,
    this.w_mask = 0,
    this.window = null,
    this.window_size = 0,
    this.prev = null,
    this.head = null,
    this.ins_h = 0,
    this.hash_size = 0,
    this.hash_bits = 0,
    this.hash_mask = 0,
    this.hash_shift = 0,
    this.block_start = 0,
    this.match_length = 0,
    this.prev_match = 0,
    this.match_available = 0,
    this.strstart = 0,
    this.match_start = 0,
    this.lookahead = 0,
    this.prev_length = 0,
    this.max_chain_length = 0,
    this.max_lazy_match = 0,
    this.level = 0,
    this.strategy = 0,
    this.good_match = 0,
    this.nice_match = 0,
    this.dyn_ltree = new Uint16Array(1146),
    this.dyn_dtree = new Uint16Array(122),
    this.bl_tree = new Uint16Array(78),
    ft(this.dyn_ltree),
    ft(this.dyn_dtree),
    ft(this.bl_tree),
    this.l_desc = null,
    this.d_desc = null,
    this.bl_desc = null,
    this.bl_count = new Uint16Array(16),
    this.heap = new Uint16Array(573),
    ft(this.heap),
    this.heap_len = 0,
    this.heap_max = 0,
    this.depth = new Uint16Array(573),
    ft(this.depth),
    this.sym_buf = 0,
    this.lit_bufsize = 0,
    this.sym_next = 0,
    this.sym_end = 0,
    this.opt_len = 0,
    this.static_len = 0,
    this.matches = 0,
    this.insert = 0,
    this.bi_buf = 0,
    this.bi_valid = 0
}
const Ut = t => {
    if (!t)
        return 1;
    const e = t.state;
    return !e || e.strm !== t || 42 !== e.status && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && 113 !== e.status && 666 !== e.status ? 1 : 0
}
  , Rt = t => {
    if (Ut(t))
        return dt(t, tt);
    t.total_in = t.total_out = 0,
    t.data_type = ht;
    const e = t.state;
    return e.pending = 0,
    e.pending_out = 0,
    e.wrap < 0 && (e.wrap = -e.wrap),
    e.status = 2 === e.wrap ? 57 : e.wrap ? 42 : 113,
    t.adler = 2 === e.wrap ? 0 : 1,
    e.last_flush = -2,
    H(e),
    V
}
  , Lt = t => {
    const e = Rt(t);
    var a;
    return e === V && ((a = t.state).window_size = 2 * a.w_size,
    ft(a.head),
    a.max_lazy_match = Zt[a.level].max_lazy,
    a.good_match = Zt[a.level].good_length,
    a.nice_match = Zt[a.level].nice_length,
    a.max_chain_length = Zt[a.level].max_chain,
    a.strstart = 0,
    a.block_start = 0,
    a.lookahead = 0,
    a.insert = 0,
    a.match_length = a.prev_length = 2,
    a.match_available = 0,
    a.ins_h = 0),
    e
}
  , Tt = (t, e, a, s, r, n) => {
    if (!t)
        return tt;
    let i = 1;
    if (e === st && (e = 6),
    s < 0 ? (i = 0,
    s = -s) : s > 15 && (i = 2,
    s -= 16),
    r < 1 || r > 9 || a !== ot || s < 8 || s > 15 || e < 0 || e > 9 || n < 0 || n > _t || 8 === s && 1 !== i)
        return dt(t, tt);
    8 === s && (s = 9);
    const _ = new St;
    return t.state = _,
    _.strm = t,
    _.status = 42,
    _.wrap = i,
    _.gzhead = null,
    _.w_bits = s,
    _.w_size = 1 << _.w_bits,
    _.w_mask = _.w_size - 1,
    _.hash_bits = r + 7,
    _.hash_size = 1 << _.hash_bits,
    _.hash_mask = _.hash_size - 1,
    _.hash_shift = ~~((_.hash_bits + 3 - 1) / 3),
    _.window = new Uint8Array(2 * _.w_size),
    _.head = new Uint16Array(_.hash_size),
    _.prev = new Uint16Array(_.w_size),
    _.lit_bufsize = 1 << r + 6,
    _.pending_buf_size = 4 * _.lit_bufsize,
    _.pending_buf = new Uint8Array(_.pending_buf_size),
    _.sym_buf = _.lit_bufsize,
    _.sym_end = 3 * (_.lit_bufsize - 1),
    _.level = e,
    _.strategy = n,
    _.method = a,
    Lt(t)
}
;
t.deflateInit = (t, e) => Tt(t, e, ot, 15, 8, lt),
t.deflateInit2 = Tt,
t.deflateReset = Lt,
t.deflateResetKeep = Rt,
t.deflateSetHeader = (t, e) => Ut(t) || 2 !== t.state.wrap ? tt : (t.state.gzhead = e,
V),
t.deflate = (t, e) => {
    if (Ut(t) || e > Q || e < 0)
        return t ? dt(t, tt) : tt;
    const a = t.state;
    if (!t.output || 0 !== t.avail_in && !t.input || 666 === a.status && e !== J)
        return dt(t, 0 === t.avail_out ? at : tt);
    const s = a.last_flush;
    if (a.last_flush = e,
    0 !== a.pending) {
        if (gt(t),
        0 === t.avail_out)
            return a.last_flush = -1,
            V
    } else if (0 === t.avail_in && ut(e) <= ut(s) && e !== J)
        return dt(t, at);
    if (666 === a.status && 0 !== t.avail_in)
        return dt(t, at);
    if (42 === a.status && 0 === a.wrap && (a.status = 113),
    42 === a.status) {
        let e = ot + (a.w_bits - 8 << 4) << 8
          , s = -1;
        if (s = a.strategy >= nt || a.level < 2 ? 0 : a.level < 6 ? 1 : 6 === a.level ? 2 : 3,
        e |= s << 6,
        0 !== a.strstart && (e |= 32),
        e += 31 - e % 31,
        bt(a, e),
        0 !== a.strstart && (bt(a, t.adler >>> 16),
        bt(a, 65535 & t.adler)),
        t.adler = 1,
        a.status = 113,
        gt(t),
        0 !== a.pending)
            return a.last_flush = -1,
            V
    }
    if (57 === a.status)
        if (t.adler = 0,
        mt(a, 31),
        mt(a, 139),
        mt(a, 8),
        a.gzhead)
            mt(a, (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)),
            mt(a, 255 & a.gzhead.time),
            mt(a, a.gzhead.time >> 8 & 255),
            mt(a, a.gzhead.time >> 16 & 255),
            mt(a, a.gzhead.time >> 24 & 255),
            mt(a, 9 === a.level ? 2 : a.strategy >= nt || a.level < 2 ? 4 : 0),
            mt(a, 255 & a.gzhead.os),
            a.gzhead.extra && a.gzhead.extra.length && (mt(a, 255 & a.gzhead.extra.length),
            mt(a, a.gzhead.extra.length >> 8 & 255)),
            a.gzhead.hcrc && (t.adler = j(t.adler, a.pending_buf, a.pending, 0)),
            a.gzindex = 0,
            a.status = 69;
        else if (mt(a, 0),
        mt(a, 0),
        mt(a, 0),
        mt(a, 0),
        mt(a, 0),
        mt(a, 9 === a.level ? 2 : a.strategy >= nt || a.level < 2 ? 4 : 0),
        mt(a, 3),
        a.status = 113,
        gt(t),
        0 !== a.pending)
            return a.last_flush = -1,
            V;
    if (69 === a.status) {
        if (a.gzhead.extra) {
            let e = a.pending
              , s = (65535 & a.gzhead.extra.length) - a.gzindex;
            for (; a.pending + s > a.pending_buf_size; ) {
                let r = a.pending_buf_size - a.pending;
                if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + r), a.pending),
                a.pending = a.pending_buf_size,
                a.gzhead.hcrc && a.pending > e && (t.adler = j(t.adler, a.pending_buf, a.pending - e, e)),
                a.gzindex += r,
                gt(t),
                0 !== a.pending)
                    return a.last_flush = -1,
                    V;
                e = 0,
                s -= r
            }
            let r = new Uint8Array(a.gzhead.extra);
            a.pending_buf.set(r.subarray(a.gzindex, a.gzindex + s), a.pending),
            a.pending += s,
            a.gzhead.hcrc && a.pending > e && (t.adler = j(t.adler, a.pending_buf, a.pending - e, e)),
            a.gzindex = 0
        }
        a.status = 73
    }
    if (73 === a.status) {
        if (a.gzhead.name) {
            let e, s = a.pending;
            do {
                if (a.pending === a.pending_buf_size) {
                    if (a.gzhead.hcrc && a.pending > s && (t.adler = j(t.adler, a.pending_buf, a.pending - s, s)),
                    gt(t),
                    0 !== a.pending)
                        return a.last_flush = -1,
                        V;
                    s = 0
                }
                e = a.gzindex < a.gzhead.name.length ? 255 & a.gzhead.name.charCodeAt(a.gzindex++) : 0,
                mt(a, e)
            } while (0 !== e);
            a.gzhead.hcrc && a.pending > s && (t.adler = j(t.adler, a.pending_buf, a.pending - s, s)),
            a.gzindex = 0
        }
        a.status = 91
    }
    if (91 === a.status) {
        if (a.gzhead.comment) {
            let e, s = a.pending;
            do {
                if (a.pending === a.pending_buf_size) {
                    if (a.gzhead.hcrc && a.pending > s && (t.adler = j(t.adler, a.pending_buf, a.pending - s, s)),
                    gt(t),
                    0 !== a.pending)
                        return a.last_flush = -1,
                        V;
                    s = 0
                }
                e = a.gzindex < a.gzhead.comment.length ? 255 & a.gzhead.comment.charCodeAt(a.gzindex++) : 0,
                mt(a, e)
            } while (0 !== e);
            a.gzhead.hcrc && a.pending > s && (t.adler = j(t.adler, a.pending_buf, a.pending - s, s))
        }
        a.status = 103
    }
    if (103 === a.status) {
        if (a.gzhead.hcrc) {
            if (a.pending + 2 > a.pending_buf_size && (gt(t),
            0 !== a.pending))
                return a.last_flush = -1,
                V;
            mt(a, 255 & t.adler),
            mt(a, t.adler >> 8 & 255),
            t.adler = 0
        }
        if (a.status = 113,
        gt(t),
        0 !== a.pending)
            return a.last_flush = -1,
            V
    }
    if (0 !== t.avail_in || 0 !== a.lookahead || e !== X && 666 !== a.status) {
        let s = 0 === a.level ? kt(a, e) : a.strategy === nt ? ( (t, e) => {
            let a;
            for (; ; ) {
                if (0 === t.lookahead && (zt(t),
                0 === t.lookahead)) {
                    if (e === X)
                        return 1;
                    break
                }
                if (t.match_length = 0,
                a = P(t, 0, t.window[t.strstart]),
                t.lookahead--,
                t.strstart++,
                a && (wt(t, !1),
                0 === t.strm.avail_out))
                    return 1
            }
            return t.insert = 0,
            e === J ? (wt(t, !0),
            0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (wt(t, !1),
            0 === t.strm.avail_out) ? 1 : 2
        }
        )(a, e) : a.strategy === it ? ( (t, e) => {
            let a, s, r, n;
            const i = t.window;
            for (; ; ) {
                if (t.lookahead <= 258) {
                    if (zt(t),
                    t.lookahead <= 258 && e === X)
                        return 1;
                    if (0 === t.lookahead)
                        break
                }
                if (t.match_length = 0,
                t.lookahead >= 3 && t.strstart > 0 && (r = t.strstart - 1,
                s = i[r],
                s === i[++r] && s === i[++r] && s === i[++r])) {
                    n = t.strstart + 258;
                    do {} while (s === i[++r] && s === i[++r] && s === i[++r] && s === i[++r] && s === i[++r] && s === i[++r] && s === i[++r] && s === i[++r] && r < n);
                    t.match_length = 258 - (n - r),
                    t.match_length > t.lookahead && (t.match_length = t.lookahead)
                }
                if (t.match_length >= 3 ? (a = P(t, 1, t.match_length - 3),
                t.lookahead -= t.match_length,
                t.strstart += t.match_length,
                t.match_length = 0) : (a = P(t, 0, t.window[t.strstart]),
                t.lookahead--,
                t.strstart++),
                a && (wt(t, !1),
                0 === t.strm.avail_out))
                    return 1
            }
            return t.insert = 0,
            e === J ? (wt(t, !0),
            0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (wt(t, !1),
            0 === t.strm.avail_out) ? 1 : 2
        }
        )(a, e) : Zt[a.level].func(a, e);
        if (3 !== s && 4 !== s || (a.status = 666),
        1 === s || 3 === s)
            return 0 === t.avail_out && (a.last_flush = -1),
            V;
        if (2 === s && (e === W ? Y(a) : e !== Q && (B(a, 0, 0, !1),
        e === q && (ft(a.head),
        0 === a.lookahead && (a.strstart = 0,
        a.block_start = 0,
        a.insert = 0))),
        gt(t),
        0 === t.avail_out))
            return a.last_flush = -1,
            V
    }
    return e !== J ? V : a.wrap <= 0 ? $ : (2 === a.wrap ? (mt(a, 255 & t.adler),
    mt(a, t.adler >> 8 & 255),
    mt(a, t.adler >> 16 & 255),
    mt(a, t.adler >> 24 & 255),
    mt(a, 255 & t.total_in),
    mt(a, t.total_in >> 8 & 255),
    mt(a, t.total_in >> 16 & 255),
    mt(a, t.total_in >> 24 & 255)) : (bt(a, t.adler >>> 16),
    bt(a, 65535 & t.adler)),
    gt(t),
    a.wrap > 0 && (a.wrap = -a.wrap),
    0 !== a.pending ? V : $)
}
,
t.deflateEnd = t => {
    if (Ut(t))
        return tt;
    const e = t.state.status;
    return t.state = null,
    113 === e ? dt(t, et) : V
}
,
t.deflateSetDictionary = (t, e) => {
    let a = e.length;
    if (Ut(t))
        return tt;
    const s = t.state
      , r = s.wrap;
    if (2 === r || 1 === r && 42 !== s.status || s.lookahead)
        return tt;
    if (1 === r && (t.adler = K(t.adler, e, a, 0)),
    s.wrap = 0,
    a >= s.w_size) {
        0 === r && (ft(s.head),
        s.strstart = 0,
        s.block_start = 0,
        s.insert = 0);
        let t = new Uint8Array(s.w_size);
        t.set(e.subarray(a - s.w_size, a), 0),
        e = t,
        a = s.w_size
    }
    const n = t.avail_in
      , i = t.next_in
      , _ = t.input;
    for (t.avail_in = a,
    t.next_in = 0,
    t.input = e,
    zt(s); s.lookahead >= 3; ) {
        let t = s.strstart
          , e = s.lookahead - 2;
        do {
            s.ins_h = pt(s, s.ins_h, s.window[t + 3 - 1]),
            s.prev[t & s.w_mask] = s.head[s.ins_h],
            s.head[s.ins_h] = t,
            t++
        } while (--e);
        s.strstart = t,
        s.lookahead = 2,
        zt(s)
    }
    return s.strstart += s.lookahead,
    s.block_start = s.strstart,
    s.insert = s.lookahead,
    s.lookahead = 0,
    s.match_length = s.prev_length = 2,
    s.match_available = 0,
    t.next_in = i,
    t.input = _,
    t.avail_in = n,
    s.wrap = r,
    V
}
,
t.deflateInfo = "pako deflate (from Nodeca project)";
var Ft = {};
const Ot = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
Ft.assign = function(t) {
    const e = Array.prototype.slice.call(arguments, 1);
    for (; e.length; ) {
        const a = e.shift();
        if (a) {
            if ("object" != typeof a)
                throw new TypeError(a + "must be non-object");
            for (const e in a)
                Ot(a, e) && (t[e] = a[e])
        }
    }
    return t
}
,
Ft.flattenChunks = t => {
    let e = 0;
    for (let a = 0, s = t.length; a < s; a++)
        e += t[a].length;
    const a = new Uint8Array(e);
    for (let e = 0, s = 0, r = t.length; e < r; e++) {
        let r = t[e];
        a.set(r, s),
        s += r.length
    }
    return a
}
;
var Dt = {};
let Nt = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch (t) {
    Nt = !1
}
const Ct = new Uint8Array(256);
for (let t = 0; t < 256; t++)
    Ct[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
Ct[254] = Ct[254] = 1,
Dt.string2buf = t => {
    if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
        return (new TextEncoder).encode(t);
    let e, a, s, r, n, i = t.length, _ = 0;
    for (r = 0; r < i; r++)
        a = t.charCodeAt(r),
        55296 == (64512 & a) && r + 1 < i && (s = t.charCodeAt(r + 1),
        56320 == (64512 & s) && (a = 65536 + (a - 55296 << 10) + (s - 56320),
        r++)),
        _ += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
    for (e = new Uint8Array(_),
    n = 0,
    r = 0; n < _; r++)
        a = t.charCodeAt(r),
        55296 == (64512 & a) && r + 1 < i && (s = t.charCodeAt(r + 1),
        56320 == (64512 & s) && (a = 65536 + (a - 55296 << 10) + (s - 56320),
        r++)),
        a < 128 ? e[n++] = a : a < 2048 ? (e[n++] = 192 | a >>> 6,
        e[n++] = 128 | 63 & a) : a < 65536 ? (e[n++] = 224 | a >>> 12,
        e[n++] = 128 | a >>> 6 & 63,
        e[n++] = 128 | 63 & a) : (e[n++] = 240 | a >>> 18,
        e[n++] = 128 | a >>> 12 & 63,
        e[n++] = 128 | a >>> 6 & 63,
        e[n++] = 128 | 63 & a);
    return e
}
;
Dt.buf2string = (t, e) => {
    const a = e || t.length;
    if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
        return (new TextDecoder).decode(t.subarray(0, e));
    let s, r;
    const n = new Array(2 * a);
    for (r = 0,
    s = 0; s < a; ) {
        let e = t[s++];
        if (e < 128) {
            n[r++] = e;
            continue
        }
        let i = Ct[e];
        if (i > 4)
            n[r++] = 65533,
            s += i - 1;
        else {
            for (e &= 2 === i ? 31 : 3 === i ? 15 : 7; i > 1 && s < a; )
                e = e << 6 | 63 & t[s++],
                i--;
            i > 1 ? n[r++] = 65533 : e < 65536 ? n[r++] = e : (e -= 65536,
            n[r++] = 55296 | e >> 10 & 1023,
            n[r++] = 56320 | 1023 & e)
        }
    }
    return ( (t, e) => {
        if (e < 65534 && t.subarray && Nt)
            return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
        let a = "";
        for (let s = 0; s < e; s++)
            a += String.fromCharCode(t[s]);
        return a
    }
    )(n, r)
}
,
Dt.utf8border = (t, e) => {
    (e = e || t.length) > t.length && (e = t.length);
    let a = e - 1;
    for (; a >= 0 && 128 == (192 & t[a]); )
        a--;
    return a < 0 || 0 === a ? e : a + Ct[t[a]] > e ? a : e
}
;
const It = t
  , Ht = Ft
  , Bt = Dt
  , Mt = C
  , Pt = function() {
    this.input = null,
    this.next_in = 0,
    this.avail_in = 0,
    this.total_in = 0,
    this.output = null,
    this.next_out = 0,
    this.avail_out = 0,
    this.total_out = 0,
    this.msg = "",
    this.state = null,
    this.data_type = 2,
    this.adler = 0
}
  , Yt = Object.prototype.toString
  , {Z_NO_FLUSH: Kt, Z_SYNC_FLUSH: jt, Z_FULL_FLUSH: Gt, Z_FINISH: Xt, Z_OK: Wt, Z_STREAM_END: qt, Z_DEFAULT_COMPRESSION: Jt, Z_DEFAULT_STRATEGY: Qt, Z_DEFLATED: Vt} = I;
function $t(t) {
    this.options = Ht.assign({
        level: Jt,
        method: Vt,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Qt
    }, t || {});
    let e = this.options;
    e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16),
    this.err = 0,
    this.msg = "",
    this.ended = !1,
    this.chunks = [],
    this.strm = new Pt,
    this.strm.avail_out = 0;
    let a = It.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
    if (a !== Wt)
        throw new Error(Mt[a]);
    if (e.header && It.deflateSetHeader(this.strm, e.header),
    e.dictionary) {
        let t;
        if (t = "string" == typeof e.dictionary ? Bt.string2buf(e.dictionary) : "[object ArrayBuffer]" === Yt.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary,
        a = It.deflateSetDictionary(this.strm, t),
        a !== Wt)
            throw new Error(Mt[a]);
        this._dict_set = !0
    }
}
$t.prototype.push = function(t, e) {
    const a = this.strm
      , s = this.options.chunkSize;
    let r, n;
    if (this.ended)
        return !1;
    for (n = e === ~~e ? e : !0 === e ? Xt : Kt,
    "string" == typeof t ? a.input = Bt.string2buf(t) : "[object ArrayBuffer]" === Yt.call(t) ? a.input = new Uint8Array(t) : a.input = t,
    a.next_in = 0,
    a.avail_in = a.input.length; ; )
        if (0 === a.avail_out && (a.output = new Uint8Array(s),
        a.next_out = 0,
        a.avail_out = s),
        (n === jt || n === Gt) && a.avail_out <= 6)
            this.onData(a.output.subarray(0, a.next_out)),
            a.avail_out = 0;
        else {
            if (r = It.deflate(a, n),
            r === qt)
                return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)),
                r = It.deflateEnd(this.strm),
                this.onEnd(r),
                this.ended = !0,
                r === Wt;
            if (0 !== a.avail_out) {
                if (n > 0 && a.next_out > 0)
                    this.onData(a.output.subarray(0, a.next_out)),
                    a.avail_out = 0;
                else if (0 === a.avail_in)
                    break
            } else
                this.onData(a.output)
        }
    return !0
}
,
$t.prototype.onData = function(t) {
    this.chunks.push(t)
}
,
$t.prototype.onEnd = function(t) {
    t === Wt && (this.result = Ht.flattenChunks(this.chunks)),
    this.chunks = [],
    this.err = t,
    this.msg = this.strm.msg
}
;
const te = $t
  , ee = function(t, e) {
    const a = new $t(e);
    if (a.push(t, !0),
    a.err)
        throw a.msg || Mt[a.err];
    return a.result
}
  , ae = I;
const se = new class {
    constructor() {
        this._init()
    }
    clear() {
        this._init()
    }
    addEvent(t) {
        if (!t)
            throw new Error("Adding invalid event");
        const e = this._hasEvents ? "," : "";
        this.deflate.push(e + t, ae.Z_SYNC_FLUSH),
        this._hasEvents = !0
    }
    finish() {
        if (this.deflate.push("]", ae.Z_FINISH),
        this.deflate.err)
            throw this.deflate.err;
        const t = this.deflate.result;
        return this._init(),
        t
    }
    _init() {
        this._hasEvents = !1,
        this.deflate = new te,
        this.deflate.push("[", ae.Z_NO_FLUSH)
    }
}
  , re = {
    clear: () => {
        se.clear()
    }
    ,
    addEvent: t => se.addEvent(t),
    finish: () => se.finish(),
    compress: t => function(t) {
        return ee(t)
    }(t)
};
addEventListener("message", (function(t) {
    const e = t.data.method
      , a = t.data.id
      , s = t.data.arg;
    if (e in re && "function" == typeof re[e])
        try {
            const t = re[e](s);
            postMessage({
                id: a,
                method: e,
                success: !0,
                response: t
            })
        } catch (t) {
            postMessage({
                id: a,
                method: e,
                success: !1,
                response: t.message
            }),
            console.error(t)
        }
}
)),
postMessage({
    id: void 0,
    method: "init",
    success: !0,
    response: void 0
});
