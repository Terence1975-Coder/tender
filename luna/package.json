# file: package.json
{
  "name": "weavi-teams-ai-coldcaller",
  "private": true,
  "packageManager": "pnpm@9.8.0",
  "scripts": {
    "build": "pnpm -r build",
    "dev": "pnpm -r --parallel dev",
    "lint": "pnpm -r lint",
    "typecheck": "pnpm -r typecheck",
    "test": "pnpm -r test",
    "e2e": "pnpm --filter @apps/web e2e",
    "format": "prettier -w .",
    "infra:plan": "cd infra/terraform && terraform init && terraform plan",
    "infra:apply": "cd infra/terraform && terraform apply -auto-approve",
    "db:migrate": "pnpm --filter @apps/api prisma:migrate",
    "db:seed": "pnpm --filter @apps/api prisma:seed"
  },
  "workspaces": [
    "apps/*",
    "packages/*",
    "docs",
    "infra/*"
  ],
  "devDependencies": {
    "@types/node": "^20.12.12",
    "prettier": "^3.3.3",
    "typescript": "^5.6.2"
  }
}

# file: pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'packages/*'
  - 'infra/*'
  - 'docs'

# file: turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**", ".next/**"] },
    "dev": { "cache": false },
    "lint": {},
    "typecheck": {},
    "test": { "dependsOn": ["build"] }
  }
}

# file: tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@repo/ai-router": ["packages/ai-router/src/index.ts"],
      "@repo/speech": ["packages/speech/src/index.ts"],
      "@repo/teams": ["packages/teams/src/index.ts"],
      "@repo/ui-theme": ["packages/ui-theme/src/index.ts"],
      "@repo/contracts": ["packages/contracts/src/index.ts"]
    }
  }
}

# file: .gitignore
node_modules
dist
.next
coverage
.env
*.log
apps/**/.next
apps/**/.turbo
apps/**/playwright-report
terraform.tfstate*
.terraform
pnpm-lock.yaml

# file: .env.example
# === Core ===
# AZURE_ENTRA_TENANT_ID: Entra tenant (GUID)
# AZURE_AD_CLIENT_ID: App registration client id for web/API
# AZURE_AD_CLIENT_SECRET: Client secret (stored in Key Vault in prod)
# NEXT_PUBLIC_AZURE_AD_CLIENT_ID: Web MSAL public client id
# NEXT_PUBLIC_API_BASE_URL: e.g. http://localhost:4000
# WEB_URL: e.g. http://localhost:3000
# CORS_ALLOWED_ORIGINS: comma separated origins
# SESSION_COOKIE_SECRET: strong random; SameSite=Lax
#
# === Azure resources ===
# AZURE_SUBSCRIPTION_ID=
# AZURE_RESOURCE_GROUP=
# AZURE_SERVICEBUS_CONNECTION=
# AZURE_STORAGE_CONNECTION=
# AZURE_BLOB_CONTAINER=calls
# AZURE_POSTGRES_URL=postgresql://user:pass@host:5432/db?schema=public
# AZURE_KEY_VAULT_URI=
# ACS_CONNECTION_STRING=endpoint=...;accesskey=...
#
# === AI Providers (use only what you enable) ===
# OPENAI_API_KEY=
# AZURE_OPENAI_ENDPOINT=
# AZURE_OPENAI_KEY=
# ANTHROPIC_API_KEY=
# GOOGLE_VERTEX_PROJECT=
# GOOGLE_VERTEX_LOCATION=
# GOOGLE_APPLICATION_CREDENTIALS=/path/to/sa.json
#
# === Speech ===
# AZURE_SPEECH_KEY=
# AZURE_SPEECH_REGION=
# DEEPGRAM_API_KEY=
# ELEVENLABS_API_KEY=
#
# === Teams/Graph ===
# GRAPH_CLIENT_ID=
# GRAPH_CLIENT_SECRET=
# GRAPH_TENANT_ID=
# TEAMS_DEFAULT_TEAM_ID=
# TEAMS_DEFAULT_CHANNEL_ID=
#
# === Security ===
# BLOCKLIST_KEYWORDS="refund,credit card,ssn"
# ALLOWLIST_PHRASES="consent,recording"
# DNC_SUPPRESSION_LIST_PATH=./docs/fixtures/dnc.txt

# file: Makefile
SHELL := /bin/bash
.PHONY: dev build test seed migrate

dev:
\tpnpm dev

build:
\tpnpm build

test:
\tpnpm test

migrate:
\tpnpm db:migrate

seed:
\tpnpm db:seed

# -----------------------------
# packages: contracts (shared types)
# -----------------------------
# file: packages/contracts/package.json
{
  "name": "@repo/contracts",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.ts",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint . || true",
    "test": "jest"
  },
  "devDependencies": {
    "typescript": "^5.6.2",
    "zod": "^3.23.8"
  },
  "dependencies": {
    "uuid": "^9.0.1"
  }
}

# file: packages/contracts/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*.ts"]
}

# file: packages/contracts/src/schemas.ts
import { z } from "zod";

export const LeadSchema = z.object({
  id: z.string().uuid().optional(),
  phone: z.string(), // E.164 validated server-side
  name: z.string().optional(),
  company: z.string().optional(),
  timezone: z.string().optional(),
  email: z.string().email().optional(),
  notes: z.string().optional(),
  priority: z.number().int().min(0).max(10).default(5),
  tags: z.array(z.string()).default([]),
  doNotCall: z.boolean().default(false),
  status: z.enum(["new","queued","dialing","in_progress","completed","failed","human_required"]).default("new")
});

export const PlaybookJsonSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  openingScript: z.string(),
  qualification: z.array(z.string()),
  objectionPatterns: z.array(z.object({ pattern: z.string(), response: z.string() })),
  compliancePreamble: z.string().optional(),
  ctas: z.array(z.object({ label: z.string(), type: z.enum(["demo","email","meeting","handoff"]) })),
  fallback: z.string().optional(),
  tone: z.enum(["friendly","authoritative","consultative","energetic"]).default("consultative"),
  maxDurationSec: z.number().int().optional(),
  language: z.string().optional(),
  sttModel: z.string().optional(),
  ttsVoice: z.string().optional(),
  modelHints: z.object({ provider: z.string(), name: z.string() }).optional()
});

export const CallInsightsSchema = z.object({
  intent: z.enum(["interest","reject","callback","voicemail","unknown"]),
  objections: z.array(z.string()).default([]),
  budget: z.string().optional(),
  authority: z.string().optional(),
  need: z.string().optional(),
  timeline: z.string().optional(),
  competitors: z.array(z.string()).default([]),
  sentiment: z.enum(["very_negative","negative","neutral","positive","very_positive"]).default("neutral"),
  callback: z.object({ requested: z.boolean(), when: z.string().optional(), number: z.string().optional() }).default({ requested: false }),
  compliance_flags: z.array(z.string()).default([]),
  needs_human_review: z.boolean().default(false)
});

export const MeritWeightsSchema = z.object({
  intent: z.number(),
  sentiment: z.number(),
  need: z.number(),
  authority: z.number(),
  timing: z.number(),
  keyword_bonus: z.number().default(0)
});

export const MeritScoreResultSchema = z.object({
  score: z.number().min(0).max(100),
  evidence: z.array(z.string()).default([])
});

export type CallInsights = z.infer<typeof CallInsightsSchema>;

export const EventEnvelopeSchema = z.object({
  id: z.string(),
  callId: z.string(),
  type: z.string(),
  payload: z.unknown(),
  createdAt: z.string()
});

export type MeritWeights = z.infer<typeof MeritWeightsSchema>;

# file: packages/contracts/src/index.ts
export * from "./schemas";

# -----------------------------
# packages: ai-router
# -----------------------------
# file: packages/ai-router/package.json
{
  "name": "@repo/ai-router",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.ts",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint . || true",
    "test": "jest"
  },
  "dependencies": {
    "@repo/contracts": "workspace:*",
    "zod": "^3.23.8",
    "openai": "^4.56.0",
    "node-fetch": "^3.3.2",
    "p-retry": "^6.2.0"
  },
  "devDependencies": {
    "typescript": "^5.6.2"
  }
}

# file: packages/ai-router/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist", "declaration": true, "declarationMap": true },
  "include": ["src/**/*.ts"]
}

# file: packages/ai-router/src/prompts.ts
export const PROMPTS = {
  callPlanner: (playbookName: string, tone: string) =>
    `You are an expert SDR following the ${playbookName} methodology. Maintain a natural, empathetic tone (${tone}). Confirm recording consent. Ask concise, open questions. If the callee asks for a human or indicates readiness for a live demo, switch to HANDOFF. Never fabricate facts; summarise what you heard before moving on.`,
  extractor:
    "Extract intent, objections, budget, authority, need, timeline, competitor mentions, and callback preferences from the transcript. Return strict JSON that matches the `CallInsights` schema.",
  safety:
    "Identify sensitive or disallowed content and mark `needs_human_review` if detected.",
  scorer:
    "Compute Merit Score 0â€“100 using the configured weights and evidence quotes from transcript."
};

# file: packages/ai-router/src/providers.ts
import OpenAI from "openai";
export type ModelProvider = "openai" | "azure-openai" | "anthropic" | "google" | "local";

export interface RouterOptions {
  provider?: ModelProvider;
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

export interface ChatArgs {
  system: string;
  messages: { role: "user" | "assistant"; content: string }[];
  tools?: any[];
  stream?: boolean;
}

export class AIRouter {
  private opts: RouterOptions;
  private openai?: OpenAI;

  constructor(opts: RouterOptions = {}) {
    this.opts = { temperature: 0.4, maxTokens: 800, ...opts };
    if (!this.opts.provider || this.opts.provider === "openai") {
      this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    }
  }

  async chat(args: ChatArgs): Promise<string> {
    // Minimal provider switch; extend as needed
    if (this.openai) {
      const resp = await this.openai.chat.completions.create({
        model: this.opts.model ?? "gpt-4o-mini",
        temperature: this.opts.temperature,
        max_tokens: this.opts.maxTokens,
        messages: [{ role: "system", content: args.system }, ...args.messages]
      });
      return resp.choices[0]?.message?.content ?? "";
    }
    throw new Error("No provider configured");
  }
}

# file: packages/ai-router/src/guardrails.ts
const PII_PATTERNS = [
  /\b\d{3}[-.\s]?\d{2}[-.\s]?\d{4}\b/g, // SSN style
  /\b\d{13,19}\b/g                     // CC # naive
];
export function maskPII(text: string): string {
  return PII_PATTERNS.reduce((acc, re) => acc.replace(re, "[REDACTED]"), text);
}
export function containsBlocked(text: string, blocklist = process.env.BLOCKLIST_KEYWORDS || ""): boolean {
  const items = blocklist.split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
  if (!items.length) return false;
  const lower = text.toLowerCase();
  return items.some(k => lower.includes(k));
}

# file: packages/ai-router/src/scoring.ts
import { MeritWeights, MeritScoreResultSchema, CallInsights } from "@repo/contracts";
export function computeMeritScore(insights: CallInsights, weights: MeritWeights) {
  const intentMap: Record<CallInsights["intent"], number> = {
    interest: 1, callback: 0.6, unknown: 0.5, voicemail: 0.2, reject: 0
  };
  const sentimentMap: Record<CallInsights["sentiment"], number> = {
    very_positive: 1, positive: 0.8, neutral: 0.5, negative: 0.2, very_negative: 0
  };
  const hasNeed = insights.need ? 1 : 0;
  const hasAuthority = /director|vp|c-level|founder|owner|head/i.test(insights.authority ?? "") ? 1 : 0;
  const goodTiming = /this quarter|next month|q\d|soon|ready/i.test(insights.timeline ?? "") ? 1 : 0;

  const z = (weights.intent * intentMap[insights.intent]) +
            (weights.sentiment * sentimentMap[insights.sentiment]) +
            (weights.need * hasNeed) +
            (weights.authority * hasAuthority) +
            (weights.timing * goodTiming) + (weights.keyword_bonus || 0);

  const sigmoid = (x: number) => 1 / (1 + Math.exp(-x));
  const score = Math.round(sigmoid(z) * 100);
  return MeritScoreResultSchema.parse({ score, evidence: [] });
}

# file: packages/ai-router/src/index.ts
export * from "./providers";
export * from "./prompts";
export * from "./guardrails";
export * from "./scoring";

# -----------------------------
# packages: speech
# -----------------------------
# file: packages/speech/package.json
{
  "name": "@repo/speech",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.ts",
  "dependencies": {
    "eventemitter3": "^5.0.1"
  },
  "devDependencies": {
    "typescript": "^5.6.2"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint . || true",
    "test": "jest"
  }
}

# file: packages/speech/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist", "declaration": true, "declarationMap": true },
  "include": ["src/**/*.ts"]
}

# file: packages/speech/src/types.ts
import { EventEmitter } from "eventemitter3";

export interface STTChunk {
  text: string;
  isFinal: boolean;
  startTimeMs?: number;
  endTimeMs?: number;
  speaker?: "agent" | "lead";
}
export interface STTStream extends EventEmitter {
  stop(): Promise<void>;
}
export interface STTAdapter {
  startStream(opts: { language?: string; diarize?: boolean }): Promise<STTStream>;
}
export interface TTSAdapter {
  synthesize(text: string, opts: { voice?: string; speed?: number }): Promise<Buffer>;
}

# file: packages/speech/src/azure.ts
import { STTAdapter, STTStream, TTSAdapter } from "./types";
import { EventEmitter } from "eventemitter3";

// NOTE: Placeholder implementation; wire Azure SDK in real deployments.
// Why: Keep repo compilable without requiring cloud creds.
export class AzureSTTAdapter implements STTAdapter {
  async startStream(): Promise<STTStream> {
    const emitter = new EventEmitter() as STTStream;
    (emitter as any).stop = async () => {};
    return emitter;
  }
}
export class AzureTTSAdapter implements TTSAdapter {
  async synthesize(text: string): Promise<Buffer> {
    return Buffer.from(`AUDIO:${text}`);
  }
}

# file: packages/speech/src/index.ts
export * from "./types";
export * from "./azure";

# -----------------------------
# packages: teams
# -----------------------------
# file: packages/teams/package.json
{
  "name": "@repo/teams",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.ts",
  "dependencies": {
    "@azure/communication-call-automation": "^1.2.0",
    "@azure/storage-blob": "^12.18.0",
    "@azure/service-bus": "^7.9.5",
    "@microsoft/microsoft-graph-client": "^3.0.7",
    "isomorphic-fetch": "^3.0.0"
  },
  "devDependencies": { "typescript": "^5.6.2" },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  }
}

# file: packages/teams/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist", "declaration": true, "declarationMap": true },
  "include": ["src/**/*.ts"]
}

# file: packages/teams/src/acs.ts
import { CallAutomationClient } from "@azure/communication-call-automation";

export interface OutboundCallArgs {
  toPhoneE164: string;
  recording?: boolean;
  callbackUrl: string;
  correlationId: string;
}

export class ACSClient {
  private client: CallAutomationClient;
  constructor() {
    const conn = process.env.ACS_CONNECTION_STRING;
    if (!conn) throw new Error("ACS_CONNECTION_STRING required");
    this.client = new CallAutomationClient(conn);
  }
  async placeOutboundCall(args: OutboundCallArgs) {
    // Why: Provide a deterministic call id for correlating events
    return this.client.createCall({
      targets: [{ phoneNumber: { value: args.toPhoneE164 } }],
      callbackUrl: args.callbackUrl,
      mediaStreamingConfiguration: { transportUrl: args.callbackUrl, contentType: "audio", audioFormat: "wav" },
      operationContext: args.correlationId
    });
  }
}

# file: packages/teams/src/graph.ts
import { Client } from "@microsoft/microsoft-graph-client";
import "isomorphic-fetch";

export function graphClient() {
  const tenantId = process.env.GRAPH_TENANT_ID!;
  const clientId = process.env.GRAPH_CLIENT_ID!;
  const clientSecret = process.env.GRAPH_CLIENT_SECRET!;
  if (!tenantId || !clientId || !clientSecret) throw new Error("Graph env missing");
  const authProvider = {
    getAccessToken: async () => {
      const tokenResp = await fetch(`https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "client_credentials",
          client_id: clientId,
          client_secret: clientSecret,
          scope: "https://graph.microsoft.com/.default"
        })
      });
      const json = await tokenResp.json();
      return json.access_token as string;
    }
  };
  return Client.initWithMiddleware({ authProvider });
}

export async function postAdaptiveCard(teamId: string, channelId: string, card: unknown) {
  const client = graphClient();
  return client.api(`/teams/${teamId}/channels/${channelId}/messages`)
    .post({ subject: "AI Handoff", body: { contentType: "html", content: "<p>AI handoff</p>" }, attachments: [{ contentType: "application/vnd.microsoft.card.adaptive", content: card }] });
}

# file: packages/teams/src/index.ts
export * from "./acs";
export * from "./graph";

# -----------------------------
# packages: ui-theme
# -----------------------------
# file: packages/ui-theme/package.json
{
  "name": "@repo/ui-theme",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.ts",
  "dependencies": { "tailwindcss": "^3.4.10" }
}

# file: packages/ui-theme/src/index.ts
export const theme = {
  colors: {
    background: "#f6f5ff",
    card: "#ffffff",
    primary: "#7056ff",
    accent: "#2cc5b9",
    text: "#1e1b4b",
    subtle: "#a9a6d2"
  },
  radius: { xl: "1.25rem", "2xl": "1.5rem" },
  shadow: { soft: "0 10px 30px rgba(112,86,255,0.12)" }
};

# -----------------------------
# apps/api (NestJS)
# -----------------------------
# file: apps/api/package.json
{
  "name": "@apps/api",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/main.js",
  "scripts": {
    "dev": "nest start --watch",
    "build": "nest build",
    "lint": "eslint . || true",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "test": "jest",
    "prisma:migrate": "prisma migrate dev",
    "prisma:generate": "prisma generate",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^10.4.5",
    "@nestjs/core": "^10.4.5",
    "@nestjs/platform-fastify": "^10.4.5",
    "@nestjs/swagger": "^7.4.2",
    "@nestjs/websockets": "^10.4.5",
    "@prisma/client": "^5.19.0",
    "@repo/contracts": "workspace:*",
    "@repo/ai-router": "workspace:*",
    "@repo/teams": "workspace:*",
    "pino": "^9.3.2",
    "pino-pretty": "^11.2.2",
    "fastify-helmet": "^12.2.0",
    "fastify-cors": "^9.0.1",
    "zod": "^3.23.8",
    "csurf": "^1.11.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "jwks-rsa": "^3.1.0",
    "@nestjs/jwt": "^10.2.0",
    "socket.io": "^4.7.5",
    "@nestjs/websockets/socket.io-adapter": "^1.0.2",
    "@azure/service-bus": "^7.9.5"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.4.5",
    "@nestjs/schematics": "^10.1.3",
    "@types/node": "^20.12.12",
    "typescript": "^5.6.2",
    "prisma": "^5.19.0",
    "ts-node": "^10.9.2"
  }
}

# file: apps/api/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist" },
  "include": ["src/**/*.ts", "prisma/**/*.ts"]
}

# file: apps/api/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("AZURE_POSTGRES_URL")
}
model User {
  id          String @id @default(uuid())
  email       String @unique
  name        String?
  role        String  // admin|agent|reviewer
  teamsUserId String?
}
model Lead {
  id        String   @id @default(uuid())
  phone     String
  name      String?
  company   String?
  timezone  String?
  email     String?
  notes     String?
  priority  Int      @default(5)
  tags      String[]
  doNotCall Boolean  @default(false)
  status    String   @default("new")
  calls     Call[]
}
model Call {
  id             String   @id @default(uuid())
  leadId         String
  lead           Lead     @relation(fields: [leadId], references: [id])
  startedAt      DateTime @default(now())
  endedAt        DateTime?
  durationSec    Int?
  playbookId     String?
  transcriptUrl  String?
  audioUrl       String?
  sentiment      String?
  intent         String?
  meritScore     Int?
  handoff        Boolean  @default(false)
  handoffReason  String?
  handoffToUserId String?
  events         Event[]
}
model Playbook {
  id        String   @id @default(uuid())
  name      String
  version   Int      @default(1)
  json      Json
  createdBy String?
}
model Event {
  id        String   @id @default(uuid())
  callId    String
  call      Call     @relation(fields: [callId], references: [id])
  type      String
  payloadJson Json
  createdAt DateTime @default(now())
}
model ProviderConfig {
  id          String   @id @default(uuid())
  type        String
  settingsJson Json
  createdBy   String?
}

# file: apps/api/prisma/seed.ts
import { PrismaClient } from "@prisma/client";
import fs from "node:fs";
const prisma = new PrismaClient();
async function main() {
  const playbooks = JSON.parse(fs.readFileSync("../../docs/fixtures/playbooks.json","utf8"));
  for (const p of playbooks) {
    await prisma.playbook.create({ data: { name: p.name, json: p, version: 1 } });
  }
  await prisma.user.upsert({
    where: { email: "admin@example.com" },
    update: {},
    create: { email: "admin@example.com", name: "Admin", role: "admin" }
  });
}
main().finally(()=>prisma.$disconnect());

# file: apps/api/src/main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./modules/app.module.js";
import { FastifyAdapter } from "@nestjs/platform-fastify";
import helmet from "helmet";

async function bootstrap() {
  const app = await NestFactory.create(AppModule, new FastifyAdapter({ logger: true }));
  app.enableCors({ origin: (process.env.CORS_ALLOWED_ORIGINS || "").split(",").filter(Boolean), credentials: true });
  app.use(helmet({ contentSecurityPolicy: { useDefaults: true } }));
  await app.listen(4000, "0.0.0.0");
}
bootstrap();

# file: apps/api/src/modules/app.module.ts
import { Module } from "@nestjs/common";
import { LeadsModule } from "./leads/leads.module.js";
import { CallsModule } from "./calls/calls.module.js";
import { PlaybooksModule } from "./playbooks/playbooks.module.js";
import { TeamsModule } from "./teams/teams.module.js";
import { WebhooksModule } from "./webhooks/webhooks.module.js";
import { EventsGateway } from "./events/events.gateway.js";
import { PrismaService } from "../prisma.service.js";

@Module({
  imports: [LeadsModule, CallsModule, PlaybooksModule, TeamsModule, WebhooksModule],
  providers: [EventsGateway, PrismaService]
})
export class AppModule {}

# file: apps/api/src/prisma.service.ts
import { INestApplication, Injectable, OnModuleInit } from "@nestjs/common";
import { PrismaClient } from "@prisma/client";
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() { await this.$connect(); }
  async enableShutdownHooks(app: INestApplication) {
    this.$on("beforeExit", async () => { await app.close(); });
  }
}

# file: apps/api/src/modules/events/events.gateway.ts
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import { Server } from "socket.io";

@WebSocketGateway({ namespace: "/events", cors: { origin: true } })
export class EventsGateway {
  @WebSocketServer() server!: Server;
  publish(event: { type: string; callId: string; payload: unknown }) {
    this.server.emit(event.type, event);
  }
}

# file: apps/api/src/modules/leads/leads.module.ts
import { Module } from "@nestjs/common";
import { LeadsService } from "./leads.service.js";
import { LeadsController } from "./leads.controller.js";
import { PrismaService } from "../../prisma.service.js";

@Module({ controllers: [LeadsController], providers: [LeadsService, PrismaService] })
export class LeadsModule {}

# file: apps/api/src/modules/leads/leads.service.ts
import { Injectable } from "@nestjs/common";
import { PrismaService } from "../../prisma.service.js";
import { Lead } from "@prisma/client";

@Injectable()
export class LeadsService {
  constructor(private prisma: PrismaService) {}
  create(data: Partial<Lead>) { return this.prisma.lead.create({ data: data as any }); }
  list() { return this.prisma.lead.findMany({ orderBy: { priority: "desc" } }); }
  update(id: string, data: Partial<Lead>) { return this.prisma.lead.update({ where: { id }, data }); }
}

# file: apps/api/src/modules/leads/leads.controller.ts
import { Body, Controller, Get, Patch, Post, UploadedFile, UseInterceptors } from "@nestjs/common";
import { LeadsService } from "./leads.service.js";
import { FileInterceptor } from "@nestjs/platform-fastify/multer";
import { parse } from "csv-parse/sync";

@Controller("leads")
export class LeadsController {
  constructor(private leads: LeadsService) {}
  @Post() create(@Body() body: any) { return this.leads.create(body); }
  @Get() list() { return this.leads.list(); }
  @Patch(":id") update() { return { ok: true }; } // kept minimal
  @Post("import")
  @UseInterceptors(FileInterceptor("file"))
  async importCsv(@UploadedFile() file: Express.Multer.File) {
    const rows = parse(file.buffer, { columns: true, skip_empty_lines: true });
    const created = [];
    for (const r of rows) {
      created.push(await this.leads.create({
        phone: r.phone, name: r.name, company: r.company, timezone: r.timezone, email: r.email,
        notes: r.notes, priority: Number(r.priority ?? 5), tags: (r.tags||"").split(",").filter(Boolean)
      }));
    }
    return { count: created.length };
  }
}

# file: apps/api/src/modules/playbooks/playbooks.module.ts
import { Module } from "@nestjs/common";
import { PlaybooksService } from "./playbooks.service.js";
import { PlaybooksController } from "./playbooks.controller.js";
import { PrismaService } from "../../prisma.service.js";

@Module({ controllers: [PlaybooksController], providers: [PlaybooksService, PrismaService] })
export class PlaybooksModule {}

# file: apps/api/src/modules/playbooks/playbooks.service.ts
import { Injectable } from "@nestjs/common";
import { PrismaService } from "../../prisma.service.js";

@Injectable()
export class PlaybooksService {
  constructor(private prisma: PrismaService) {}
  list() { return this.prisma.playbook.findMany(); }
  get(id: string) { return this.prisma.playbook.findUnique({ where: { id } }); }
  create(data: any) { return this.prisma.playbook.create({ data }); }
  validate(json: any) { return { valid: true }; }
}

# file: apps/api/src/modules/playbooks/playbooks.controller.ts
import { Body, Controller, Get, Param, Post } from "@nestjs/common";
import { PlaybooksService } from "./playbooks.service.js";

@Controller("playbooks")
export class PlaybooksController {
  constructor(private service: PlaybooksService) {}
  @Get() list() { return this.service.list(); }
  @Get(":id") get(@Param("id") id: string) { return this.service.get(id); }
  @Post() create(@Body() body: any) { return this.service.create(body); }
  @Post("validate") validate(@Body() body: any) { return this.service.validate(body); }
}

# file: apps/api/src/modules/calls/calls.module.ts
import { Module } from "@nestjs/common";
import { CallsController } from "./calls.controller.js";
import { CallsService } from "./calls.service.js";
import { PrismaService } from "../../prisma.service.js";
import { EventsGateway } from "../events/events.gateway.js";

@Module({ controllers: [CallsController], providers: [CallsService, PrismaService, EventsGateway] })
export class CallsModule {}

# file: apps/api/src/modules/calls/calls.service.ts
import { Injectable } from "@nestjs/common";
import { PrismaService } from "../../prisma.service.js";
import { ServiceBusClient } from "@azure/service-bus";
import { EventsGateway } from "../events/events.gateway.js";

@Injectable()
export class CallsService {
  private sb?: ServiceBusClient;
  constructor(private prisma: PrismaService, private events: EventsGateway) {
    const conn = process.env.AZURE_SERVICEBUS_CONNECTION;
    if (conn) this.sb = new ServiceBusClient(conn);
  }
  async start(payload: { leadId?: string; phone?: string; playbookId?: string; voice?: string; model?: string }) {
    const lead = payload.leadId
      ? await this.prisma.lead.findUnique({ where: { id: payload.leadId } })
      : await this.prisma.lead.create({ data: { phone: payload.phone!, status: "queued" } });
    const call = await this.prisma.call.create({ data: { leadId: lead!.id, playbookId: payload.playbookId } });
    this.events.publish({ type: "call.queued", callId: call.id, payload: { leadId: lead!.id } });
    if (this.sb) {
      const sender = this.sb.createSender("dial-queue");
      await sender.sendMessages({ body: { callId: call.id, leadId: lead!.id, playbookId: payload.playbookId } });
    }
    return { id: call.id };
  }
  get(id: string) { return this.prisma.call.findUnique({ where: { id } }); }
}

# file: apps/api/src/modules/calls/calls.controller.ts
import { Body, Controller, Get, Param, Post } from "@nestjs/common";
import { CallsService } from "./calls.service.js";

@Controller("calls")
export class CallsController {
  constructor(private service: CallsService) {}
  @Post("start") start(@Body() body: any) { return this.service.start(body); }
  @Get(":id") get(@Param("id") id: string) { return this.service.get(id); }
  @Post(":id/handoff") handoff() { return { ok: true }; }
}

# file: apps/api/src/modules/teams/teams.module.ts
import { Module } from "@nestjs/common";
import { TeamsController } from "./teams.controller.js";

@Module({ controllers: [TeamsController] })
export class TeamsModule {}

# file: apps/api/src/modules/teams/teams.controller.ts
import { Body, Controller, Post } from "@nestjs/common";
import { postAdaptiveCard } from "@repo/teams";

@Controller("teams")
export class TeamsController {
  @Post("notify")
  async notify(@Body() body: any) {
    const card = body.card ?? { type: "AdaptiveCard", version: "1.5", body: [{ type: "TextBlock", text: "AI handoff", weight: "Bolder" }] };
    const teamId = process.env.TEAMS_DEFAULT_TEAM_ID!;
    const channelId = process.env.TEAMS_DEFAULT_CHANNEL_ID!;
    await postAdaptiveCard(teamId, channelId, card);
    return { ok: true };
  }
  @Post("call-human")
  async callHuman() { return { ok: true }; } // Stub: see worker-calls bridge
}

# file: apps/api/src/modules/webhooks/webhooks.module.ts
import { Module } from "@nestjs/common";
import { WebhooksController } from "./webhooks.controller.js";
import { PrismaService } from "../../prisma.service.js";
import { EventsGateway } from "../events/events.gateway.js";

@Module({ controllers: [WebhooksController], providers: [PrismaService, EventsGateway] })
export class WebhooksModule {}

# file: apps/api/src/modules/webhooks/webhooks.controller.ts
import { Body, Controller, Post } from "@nestjs/common";
import { PrismaService } from "../../prisma.service.js";
import { EventsGateway } from "../events/events.gateway.js";

@Controller("webhooks")
export class WebhooksController {
  constructor(private prisma: PrismaService, private events: EventsGateway) {}
  @Post("acs")
  async acs(@Body() body: any) {
    // Why: surface real-time events to dashboard; persist for audit
    const callId = body?.operationContext || body?.callConnectionId || "unknown";
    if (callId !== "unknown") {
      const call = await this.prisma.call.findUnique({ where: { id: callId } }).catch(()=>null);
      if (call) {
        await this.prisma.event.create({ data: { callId: call.id, type: body.type || "acs.event", payloadJson: body } });
      }
    }
    this.events.publish({ type: "acs.event", callId, payload: body });
    return { ok: true };
  }
}

# -----------------------------
# apps/worker-calls (Fastify + state machine)
# -----------------------------
# file: apps/worker-calls/package.json
{
  "name": "@apps/worker-calls",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "dependencies": {
    "@azure/service-bus": "^7.9.5",
    "@prisma/client": "^5.19.0",
    "@repo/ai-router": "workspace:*",
    "@repo/contracts": "workspace:*",
    "@repo/speech": "workspace:*",
    "@repo/teams": "workspace:*",
    "fastify": "^4.28.1",
    "pino": "^9.3.2"
  },
  "devDependencies": {
    "typescript": "^5.6.2",
    "ts-node": "^10.9.2",
    "prisma": "^5.19.0"
  }
}

# file: apps/worker-calls/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist" },
  "include": ["src/**/*.ts"]
}

# file: apps/worker-calls/src/state.ts
export type CallState =
  | "Init" | "Intro" | "Consent" | "Qualify" | "HandleObjection" | "CTA" | "WrapUp" | "Handoff" | "End" | "Voicemail";

export interface CallContext {
  callId: string;
  playbook: any;
  transcript: string[];
  handoffRequested: boolean;
  hasConsent: boolean;
  attempts: number;
}

export function nextState(state: CallState, ctx: CallContext): CallState {
  if (state === "Init") return "Intro";
  if (state === "Intro") return "Consent";
  if (state === "Consent") return ctx.hasConsent ? "Qualify" : "WrapUp";
  if (state === "Qualify") return ctx.handoffRequested ? "Handoff" : "CTA";
  if (state === "HandleObjection") return "Qualify";
  if (state === "CTA") return ctx.handoffRequested ? "Handoff" : "WrapUp";
  if (state === "Handoff") return "End";
  return "End";
}

# file: apps/worker-calls/src/index.ts
import Fastify from "fastify";
import { ServiceBusClient } from "@azure/service-bus";
import { PrismaClient } from "@prisma/client";
import { AIRouter, PROMPTS, computeMeritScore } from "@repo/ai-router";
import { AzureSTTAdapter, AzureTTSAdapter } from "@repo/speech";
import { ACSClient } from "@repo/teams";
import { nextState, CallContext, CallState } from "./state.js";

const app = Fastify({ logger: true });
const prisma = new PrismaClient();
const sb = process.env.AZURE_SERVICEBUS_CONNECTION ? new ServiceBusClient(process.env.AZURE_SERVICEBUS_CONNECTION!) : undefined;

async function runCall(callId: string, playbook: any) {
  const router = new AIRouter({ provider: "openai" });
  const stt = new AzureSTTAdapter();
  const tts = new AzureTTSAdapter();

  const ctx: CallContext = { callId, playbook, transcript: [], handoffRequested: false, hasConsent: false, attempts: 0 };
  let state: CallState = "Init";

  // Place call via ACS (server-side PSTN)
  const acs = new ACSClient();
  await acs.placeOutboundCall({ toPhoneE164: "+15551230000", callbackUrl: process.env.WEB_URL + "/api/acs", correlationId: callId });

  while (state !== "End") {
    app.log.info({ callId, state }, "Call loop tick");

    if (state === "Intro") {
      const msg = playbook.openingScript;
      await tts.synthesize(msg, { voice: playbook.ttsVoice });
      ctx.transcript.push(`agent: ${msg}`);
    }

    if (state === "Consent") {
      const consent = playbook.compliancePreamble || "This call may be recorded for quality. Do you consent?";
      await tts.synthesize(consent, { voice: playbook.ttsVoice });
      ctx.transcript.push(`agent: ${consent}`);
      // Stub consent as true for demo
      ctx.hasConsent = true;
    }

    if (state === "Qualify") {
      const q = playbook.qualification[0] || "Could you share your current workflow for X?";
      const system = PROMPTS.callPlanner(playbook.name, playbook.tone || "consultative");
      const reply = await router.chat({ system, messages: [{ role: "user", content: `Lead said: "Tell me more"` }] });
      ctx.transcript.push(`agent: ${reply}`);
      // Naive handoff trigger
      if (/talk to (a )?person|human|rep|sales/i.test(reply)) ctx.handoffRequested = true;
    }

    if (state === "CTA") {
      const cta = playbook.ctas[0]?.label || "Would you like to schedule a quick demo?";
      ctx.transcript.push(`agent: ${cta}`);
    }

    if (state === "Handoff") {
      // Confirm number (stub) and mark
      await prisma.call.update({ where: { id: callId }, data: { handoff: true, handoffReason: "Lead requested human" } });
      break;
    }

    if (state === "WrapUp") {
      ctx.transcript.push("agent: Thanks for your time. Goodbye.");
    }

    state = nextState(state, ctx);
  }

  // Insights + scoring (stubbed extractor sentiment/intent)
  const insights = { intent: ctx.handoffRequested ? "interest" : "unknown", sentiment: "positive", need: "improve outbound", authority: "Head of Sales", timeline: "this quarter", objections: [], competitors: [], callback: { requested: false }, compliance_flags: [], needs_human_review: false } as any;
  const score = computeMeritScore(insights, { intent: 2, sentiment: 1, need: 1, authority: 1, timing: 1, keyword_bonus: 0 });

  await prisma.call.update({ where: { id: callId }, data: {
    intent: insights.intent, sentiment: insights.sentiment, meritScore: score.score
  }});
}

app.post("/jobs/dial", async (req, res) => {
  const { callId, playbookId } = (req.body as any) || {};
  const playbook = await prisma.playbook.findUnique({ where: { id: playbookId } });
  await runCall(callId, playbook?.json || {});
  return res.send({ ok: true });
});

app.listen({ port: 4100, host: "0.0.0.0" });

if (sb) {
  const receiver = sb.createReceiver("dial-queue");
  receiver.subscribe({
    async processMessage(msg) {
      const { callId, playbookId } = msg.body;
      await runCall(callId, { ...(await prisma.playbook.findUnique({ where: { id: playbookId } }))?.json });
    },
    async processError(err) { app.log.error(err, "SB error"); }
  });
}

# -----------------------------
# apps/ingestor
# -----------------------------
# file: apps/ingestor/package.json
{
  "name": "@apps/ingestor",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc -p tsconfig.json"
  },
  "dependencies": {
    "@azure/service-bus": "^7.9.5",
    "@prisma/client": "^5.19.0",
    "csv-parse": "^5.5.6",
    "libphonenumber-js": "^1.11.7"
  },
  "devDependencies": { "typescript": "^5.6.2", "ts-node": "^10.9.2", "prisma": "^5.19.0" }
}

# file: apps/ingestor/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "outDir": "dist" },
  "include": ["src/**/*.ts"]
}

# file: apps/ingestor/src/index.ts
import { PrismaClient } from "@prisma/client";
import { parse } from "csv-parse";
import fs from "node:fs";
import { parsePhoneNumber } from "libphonenumber-js";
import { ServiceBusClient } from "@azure/service-bus";

const prisma = new PrismaClient();
const sb = new ServiceBusClient(process.env.AZURE_SERVICEBUS_CONNECTION!);

export async function importCsv(path: string) {
  const sender = sb.createSender("dial-queue");
  const stream = fs.createReadStream(path).pipe(parse({ columns: true }));
  for await (const row of stream) {
    try {
      const phone = parsePhoneNumber(row.phone).format("E.164");
      const lead = await prisma.lead.upsert({
        where: { phone },
        update: { name: row.name, company: row.company },
        create: { phone, name: row.name, company: row.company, timezone: row.timezone, status: "queued" }
      });
      await sender.sendMessages({ body: { leadId: lead.id, callId: "", playbookId: process.env.DEFAULT_PLAYBOOK_ID } });
    } catch (e) {
      console.error("Row failed", row, e);
    }
  }
}

if (process.argv[2]) importCsv(process.argv[2]).then(()=>process.exit(0));

# -----------------------------
# apps/web (Next.js 14 w/ App Router)
# -----------------------------
# file: apps/web/package.json
{
  "name": "@apps/web",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "eslint . || true",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "e2e": "cypress run"
  },
  "dependencies": {
    "next": "14.2.7",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "zustand": "^4.5.4",
    "@tanstack/react-query": "^5.51.15",
    "axios": "^1.7.4",
    "socket.io-client": "^4.7.5",
    "framer-motion": "^11.3.19",
    "tailwindcss": "^3.4.10",
    "@repo/ui-theme": "workspace:*"
  },
  "devDependencies": { "typescript": "^5.6.2", "@types/node": "^20.12.12", "@types/react": "^18.3.7" }
}

# file: apps/web/tailwind.config.ts
import type { Config } from "tailwindcss";
import { theme } from "@repo/ui-theme";
export default {
  content: ["./app/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}"],
  theme: {
    extend: {
      colors: {
        background: theme.colors.background,
        primary: theme.colors.primary,
        accent: theme.colors.accent,
        text: theme.colors.text,
        subtle: theme.colors.subtle
      },
      borderRadius: { xl: theme.radius.xl, "2xl": theme.radius["2xl"] },
      boxShadow: { soft: theme.shadow.soft }
    }
  },
  plugins: []
} satisfies Config;

# file: apps/web/postcss.config.js
module.exports = { plugins: { tailwindcss: {}, autoprefixer: {} } };

# file: apps/web/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": { "jsx": "react-jsx", "outDir": "dist" },
  "include": ["app/**/*.ts", "app/**/*.tsx", "components/**/*.ts", "components/**/*.tsx"]
}

# file: apps/web/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;
body { @apply bg-background text-text; }
.card { @apply rounded-2xl shadow-soft bg-white; }

# file: apps/web/app/layout.tsx
import "./globals.css";
import Link from "next/link";
import { ReactNode } from "react";

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <div className="flex min-h-screen">
          <aside className="w-64 p-4 bg-white border-r">
            <div className="font-bold text-2xl text-primary mb-6">Weavi Calls</div>
            <nav className="space-y-2">
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/">Dashboard</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/opportunities">Opportunities</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/research">Research</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/marketing">Marketing</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/operations">Operations</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/settings">Settings</Link>
              <Link className="block px-3 py-2 rounded-xl hover:bg-background" href="/saas">SaaS Place</Link>
            </nav>
          </aside>
          <main className="flex-1 p-8">{children}</main>
        </div>
      </body>
    </html>
  );
}

# file: apps/web/app/page.tsx
"use client";
import { useEffect, useState } from "react";
import io from "socket.io-client";
import axios from "axios";

export default function Dashboard() {
  const [events, setEvents] = useState<any[]>([]);
  const [phone, setPhone] = useState("+15551234567");
  const [playbooks, setPlaybooks] = useState<any[]>([]);
  const api = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:4000";

  useEffect(() => {
    axios.get(`${api}/playbooks`).then(r => setPlaybooks(r.data));
    const socket = io(`${api}/events`, { transports: ["websocket"] });
    socket.onAny((event, data) => setEvents(e => [data, ...e].slice(0, 50)));
    return () => socket.close();
  }, []);

  async function startCall() {
    const playbookId = playbooks[0]?.id;
    await axios.post(`${api}/calls/start`, { phone, playbookId });
  }

  return (
    <div className="space-y-6">
      <div className="card p-6">
        <h1 className="text-3xl font-bold mb-2">Todayâ€™s Calls</h1>
        <p className="text-subtle">Single test number</p>
        <div className="mt-4 flex gap-3">
          <input className="border rounded-xl px-4 py-2 w-64" value={phone} onChange={e => setPhone(e.target.value)} placeholder="+E.164" />
          <button onClick={startCall} className="px-4 py-2 rounded-xl bg-primary text-white">Start AI Call</button>
        </div>
      </div>

      <div className="grid grid-cols-3 gap-6">
        <div className="card p-6 col-span-2">
          <h2 className="text-xl font-semibold mb-4">Live Events</h2>
          <ul className="space-y-2 max-h-96 overflow-auto">
            {events.map((e, i) => <li key={i} className="p-3 rounded-xl bg-background">{JSON.stringify(e)}</li>)}
          </ul>
        </div>
        <div className="card p-6">
          <h2 className="text-xl font-semibold mb-4">Upload CSV</h2>
          <form className="space-y-2" action={`${api}/leads/import`} method="post" encType="multipart/form-data">
            <input type="file" name="file" accept=".csv" className="block"/>
            <button className="px-4 py-2 rounded-xl bg-accent text-white">Import</button>
          </form>
        </div>
      </div>
    </div>
  );
}

# file: apps/web/app/marketing/page.tsx
"use client";
import { useEffect, useState } from "react";
import axios from "axios";

export default function Marketing() {
  const api = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:4000";
  const [list, setList] = useState<any[]>([]);
  const [json, setJson] = useState("");
  useEffect(() => { axios.get(`${api}/playbooks`).then(r => setList(r.data)); }, []);
  function download(pb: any) {
    const blob = new Blob([JSON.stringify(pb.json, null, 2)], { type: "application/json" });
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = `${pb.name}.json`; a.click();
  }
  async function upload() {
    const data = JSON.parse(json);
    await axios.post(`${api}/playbooks`, { name: data.name, json: data });
    const r = await axios.get(`${api}/playbooks`); setList(r.data);
    setJson("");
  }
  return (
    <div className="space-y-6">
      <div className="card p-6">
        <h1 className="text-3xl font-bold">Playbooks</h1>
        <p className="text-subtle">Duplicate, edit, upload/download, version</p>
      </div>
      <div className="grid grid-cols-2 gap-6">
        <div className="card p-6">
          <h2 className="text-xl mb-2">Library</h2>
          <ul className="space-y-2">
            {list.map((p:any)=>(
              <li key={p.id} className="p-3 bg-background rounded-xl flex items-center justify-between">
                <div>
                  <div className="font-semibold">{p.name}</div>
                  <div className="text-sm text-subtle">v{p.version}</div>
                </div>
                <button className="px-3 py-2 rounded-xl bg-primary text-white" onClick={()=>download(p)}>Download</button>
              </li>
            ))}
          </ul>
        </div>
        <div className="card p-6">
          <h2 className="text-xl mb-2">Upload JSON</h2>
          <textarea value={json} onChange={e=>setJson(e.target.value)} className="w-full h-64 border rounded-xl p-3" placeholder='Paste playbook JSON here'></textarea>
          <div className="mt-3"><button onClick={upload} className="px-3 py-2 rounded-xl bg-accent text-white">Upload</button></div>
        </div>
      </div>
    </div>
  );
}

# -----------------------------
# docs
# -----------------------------
# file: docs/README.md
# Weavi Teams AI Cold Caller

**Quickstart**
1. `pnpm i`
2. Copy `.env.example` to `.env` per app (web, api, worker-calls) or use Key Vault in Azure.
3. `pnpm db:migrate && pnpm db:seed`
4. `pnpm dev` (web at 3000, api at 4000, worker at 4100)

**Deploy**
- See `/infra/terraform` and `.github/workflows/deploy.yml`.

# file: docs/architecture.md
- Monorepo with pnpm workspaces.
- Next.js web UI matches Weavi style (left rail, soft purple/teal).
- NestJS API + WebSocket events, Prisma/Postgres, Service Bus queue, Blob storage, Key Vault.
- Worker service executes call state machine with ACS, STT/TTS, AI router.
- Ingestor handles CSV imports and scheduling.

# file: docs/SECURITY.md
- OIDC with Azure AD; RBAC roles.
- Secrets via Key Vault + GitHub OIDC.
- PII redaction in logs; at-rest encryption; CSP; CORS restricted.
- DNC list + quiet hours enforced in worker/ingestor.
- SAST (CodeQL), Dependabot, secret scanning enabled.

# file: docs/PRIVACY.md
- Data minimisation; deletion on request; PII masked in telemetry/logs.
- Consent captured in call flow; opt-out respected.

# file: docs/OPERATIONS.md
- Runbooks for rotating keys, scaling Container Apps, rolling deploys.
- Observability via OpenTelemetry; Prometheus/Grafana suggested dashboards.

# file: docs/TEAMS_SETUP.md
- Create ACS resource, enable Teams interop.
- Create App Registration(s) for API/web; assign Graph permissions for sending channel messages & calls.
- Configure `ACS_CONNECTION_STRING`, Graph creds, default Team/Channel IDs.
- Expose `/webhooks/acs` publicly for ACS event callbacks.

# file: docs/PLAYBOOKS.md
- JSON schema and examples for Challenger, SPIN, Consultative, MEDDICC, Value-based, Discovery-first.
- Use Marketing â†’ Upload JSON to version.

# file: docs/API.md
- `POST /calls/start` `{ phone|leadId, playbookId, voice, model }`
- `GET /calls/:id`
- `POST /calls/:id/handoff`
- `POST /leads`, `POST /leads/import`, `GET /leads`
- `GET /playbooks`, `POST /playbooks`, `POST /playbooks/validate`
- `POST /teams/notify`, `POST /teams/call-human`
- WebSocket namespace `/events`

# file: docs/fixtures/playbooks.json
[
  {
    "id": "challenger",
    "name": "Challenger",
    "description": "Teach, tailor, take control.",
    "openingScript": "Hi, it's Weavi callingâ€”quick one: we help teams book 30% more meetings. Got 30 seconds?",
    "qualification": ["How are you handling outbound connect rates today?"],
    "objectionPatterns": [{ "pattern": "not interested", "response": "Totally fairâ€”what would make this worth 10 minutes?" }],
    "compliancePreamble": "This call may be recorded for quality. Do you consent?",
    "ctas": [{ "label": "Book demo", "type": "demo" }, { "label": "Send email", "type": "email" }, { "label": "Handoff to rep", "type": "handoff" }],
    "fallback": "I'll send a brief email. Thanks!",
    "tone": "consultative",
    "language": "en-US",
    "ttsVoice": "en-US-JennyNeural",
    "modelHints": { "provider": "openai", "name": "gpt-4o-mini" }
  },
  {
    "id": "spin",
    "name": "SPIN Selling",
    "description": "Situation, Problem, Implication, Need-payoff.",
    "openingScript": "Hi, quick check-in: how are you currently generating pipeline?",
    "qualification": ["Whatâ€™s the main bottleneck today?"],
    "objectionPatterns": [{ "pattern": "no budget", "response": "If we proved ROI in weeks, would budget appear?" }],
    "ctas": [{ "label": "Schedule 20-min", "type": "meeting" }],
    "tone": "friendly",
    "ttsVoice": "en-US-GuyNeural"
  }
]

# file: docs/fixtures/sample-leads.csv
phone,name,company,role,timezone,email,notes,priority,tags
+15555550100,Casey Quinn,Quinn Co,Head of RevOps,America/Los_Angeles,casey@quinn.co,,
+15555550101,Jordan Lee,Lee Labs,VP Sales,America/New_York,jordan@leelabs.io,"Asked for Q4",8,hot,q4
+15555550102,Morgan Ray,RayHealth,Founder,Europe/London,morgan@rayhealth.com,,6,uk,healthcare

# file: docs/fixtures/dnc.txt
+15555550102

# -----------------------------
# infra/terraform
# -----------------------------
# file: infra/terraform/main.tf
terraform {
  required_version = ">= 1.6.0"
  required_providers { azurerm = { source = "hashicorp/azurerm", version = "~> 3.113" } }
}
provider "azurerm" { features {} }

variable "prefix" { type = string }
variable "location" { type = string default = "eastus" }

resource "azurerm_resource_group" "rg" { name = "${var.prefix}-rg"; location = var.location }

# Simplified: create Key Vault, Storage, Service Bus, Postgres, ACS
module "kv" {
  source              = "./modules/keyvault"
  prefix              = var.prefix
  resource_group_name = azurerm_resource_group.rg.name
  location            = var.location
}

module "sb" {
  source              = "./modules/servicebus"
  prefix              = var.prefix
  resource_group_name = azurerm_resource_group.rg.name
  location            = var.location
}

# ... add modules for storage, postgres, acs, container apps ...

output "resource_group" { value = azurerm_resource_group.rg.name }

# file: infra/terraform/modules/keyvault/main.tf
variable "prefix" { type = string }
variable "resource_group_name" { type = string }
variable "location" { type = string }
resource "azurerm_key_vault" "kv" {
  name                        = "${var.prefix}-kv"
  location                    = var.location
  resource_group_name         = var.resource_group_name
  tenant_id                   = var.prefix # replace with data.azurerm_client_config.tenant_id
  sku_name                    = "standard"
  purge_protection_enabled    = true
  soft_delete_retention_days  = 7
}

# file: infra/terraform/modules/servicebus/main.tf
variable "prefix" { type = string }
variable "resource_group_name" { type = string }
variable "location" { type = string }
resource "azurerm_servicebus_namespace" "sb" {
  name                = "${var.prefix}-sb"
  location            = var.location
  resource_group_name = var.resource_group_name
  sku                 = "Basic"
}
resource "azurerm_servicebus_queue" "dial" {
  name                = "dial-queue"
  resource_group_name = var.resource_group_name
  namespace_name      = azurerm_servicebus_namespace.sb.name
  max_delivery_count  = 10
}

# -----------------------------
# .github (CI/CD & security)
# -----------------------------
# file: .github/workflows/ci.yml
name: CI
on:
  push:
    branches: [ main ]
  pull_request:
jobs:
  build-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9.8.0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm lint
      - run: pnpm typecheck
      - run: pnpm build
      - run: pnpm test --if-present
      - uses: github/codeql-action/init@v3
        with: { languages: javascript }
      - uses: github/codeql-action/analyze@v3

# file: .github/workflows/deploy.yml
name: Deploy
on:
  workflow_dispatch:
  push:
    tags: [ "v*" ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9.8.0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Terraform Plan
        run: pnpm infra:plan
      - name: Terraform Apply
        if: github.ref_type == 'tag'
        run: pnpm infra:apply
      - name: Build images
        run: pnpm -r build

# file: .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule: { interval: "weekly" }

# -----------------------------
# Cypress e2e (smoke)
# -----------------------------
# file: apps/web/cypress.config.ts
export default { e2e: { baseUrl: "http://localhost:3000" } };

# file: apps/web/cypress/e2e/happy.spec.cy.ts
describe("Happy path", () => {
  it("loads dashboard", () => {
    cy.visit("/");
    cy.contains("Start AI Call");
  });
});

# -----------------------------
# Dockerfiles (simplified)
# -----------------------------
# file: apps/api/Dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY ../../pnpm-workspace.yaml ../../package.json ./
RUN corepack enable && corepack prepare pnpm@9.8.0 --activate
COPY . .
RUN pnpm i --filter @apps/api... && pnpm --filter @apps/api build
FROM node:20-alpine
WORKDIR /srv
COPY --from=builder /app/dist ./dist
CMD ["node","dist/main.js"]

# file: apps/web/Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN corepack enable && corepack prepare pnpm@9.8.0 --activate && pnpm i && pnpm build
CMD ["pnpm","start"]

# file: apps/worker-calls/Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN corepack enable && corepack prepare pnpm@9.8.0 --activate && pnpm i && pnpm build
CMD ["node","dist/index.js"]

